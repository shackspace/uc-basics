<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Introduction to Microcontroller Programming</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/default.css" id="theme">
  <link rel="stylesheet" href="lib/css/zenburn.css">
  <link rel="stylesheet" href="lib/font-awesome-4.1.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="css/itmp.css">
  <!--[if lt IE 9]><script src="lib/js/html5shiv.js"></script><![endif]-->
</head>
<body>
<div class="reveal">
<div id="staticnav">
  <i class="fa fa-bars fa-2x"></i>
  <br />
  <ul>
    <li><a href="#/introduction">Introduction</a></li>
    <li><a href="#/hello-world">Module 1: Hello, World!</a></li>
    <li><a href="#/irq-and-timers">Module 2: Interrupts &amp; Timers</a></li>
    <li><a href="#/leds-and-io">Module 3: LEDs &amp; I/O</a></li>
    <li><a href="#/button-control">Module 4: Button Control</a></li>
    <li><a href="#/extending-io">Module 5: Extending your I/O</a></li>
    <li><a href="#/spi">Module 6: SPI - HW Serial Data</a></li>
    <li><a href="#/digital-dimming">Module 7: Dimming Stuff Digitally</a></li>
    <li><a href="#/wrapping-up">Wrapping Up</a></li>
    <li><a href="#/meta">Meta Information</a></li>
  </ul>
</div>

<!--
#######################################################
#######################################################

                        PRELUDE

#######################################################
#######################################################
-->


<div class="slides">
<section><h4>Introduction to</h4>
  <h3>Microcontroller Programming</h3>
  <h4>using an Atmel ATmega32U4</h4>
  <div>
    <p>Joachim Fenkes (@dop3j0e)</p>
    <p>Gregor Jehle (@hdznrrd)</p>
  </div>
  <img src="lib/ccbyncsa.png">
</section>

<section><h3>Today's Goals</h3>
<ul>
  <li>Understand
    <ul class="fragment">
      <li>Microcontroller programming basics</li>
      <li>I/O and Hardware assist units</li>
      <li>Basic external peripherals</li>
      <li>Reading Datasheets</li>
    </ul>
  </li>
  <li>Implement
    <ul class="fragment">
      <li>Hello World</li>
      <li>LED Larson Scanner</li>
      <li>Button Control</li>
      <!--<li>Knob Control</li>-->
    </ul>
  </li>
</ul>
</section>

<section><h3>Who we are</h3>
<ul>
  <li>Joachim "Jocki" Fenkes
    <ul>
      <li>created the board we're using today</li>
    </ul>
  </li>

  <li>Gregor "hadez" Jehle
    <ul>
      <li>programs MCUs for a living</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Who are you?</h3>
<ul>
  <li>Please introduce yourselves with
	  <ul>
      <li>Your name</li>
	    <li><em>One</em> sentence about your prior knowledge with microcontrollers</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>Dedicated to</h3>
Jan-Bernd Themann<br/>
R.I.P., my friend
</section>

<!--
#######################################################
#######################################################

                    INTRODUCTION

#######################################################
#######################################################
-->

<section id="introduction"><h3>What is a Microcontroller?</h3>

"A microcontroller [...] is a <strong>small computer on a single integrated circuit</strong> containing a processor core, memory, and programmable input/output peripherals. Program memory [...] is also often included on chip, as well as a typically small amount of RAM. Microcontrollers are <strong>designed for embedded applications</strong> [...]"<br/>(Source: <a href="https://en.wikipedia.org/w/index.php?title=Microcontroller&oldid=607593541">Wikipedia, bit.ly/1tW56eP</a>)
</section>


<section><h3>Applications</h3>
<div style="width: 300px" class="photowrapper"><img src="lib/ranciliocoffeemachine.jpg">CC-BY-NC Faye Yu</div>
<div style="width: 300px" class="photowrapper"><img src="lib/samsungcrystalblue.jpg">CC-BY-NC-SA Samsung Tomorrow</div>
<div style="width: 300px" class="photowrapper"><img src="lib/samsungmicrowave.jpg">CC-BY-NC-SA Samsung Tomorrow</div>
</section>


<section><h3>Typical block diagram</h3>
<img src="lib/uc_blockdiagram.png">
</section>


<section><h3>Limitations</h3>
<ul>
  <li class="fragment" data-fragment-index="1">A uC ain't a PC!</li>
  <li class="fragment" data-fragment-index="1">Optimized for low power and size</li>
  <li class="fragment" data-fragment-index="1">Slow compared to a PC or a smartphone</li>
  <li class="fragment" data-fragment-index="2">Little RAM</li>
  <li class="fragment" data-fragment-index="2">No floating point unit</li>
  <li class="fragment" data-fragment-index="2">Sometimes not even HW multiplication</li>
</ul>
</section>


<section><h3>Our learning modules today</h3>
<ol>
  <li class="fragment">Hello, World!</li>
  <li class="fragment">Interrupts & Timers</li>
  <li class="fragment">LEDs & I/O</li>
  <li class="fragment">Button Control</li>
  <li class="fragment">Extending your I/O</li>
  <li class="fragment">SPI - HW serial data</li>
  <li class="fragment">(optional) Dimming stuff digitally</li>
</ol>
</section>


<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus_cpu.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus_cpu_peri.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus_cpu_peri_gpio.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus_cpu_peri_gpio_annotated.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_annotated_color.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/atmega32u4_blockdiagram.png">
</section>


<section><h3>The TinyMega Board</h3>
<ul>
  <li>The MCU itself</li>
  <li>Clock crystal (16 MHz)</li>
  <li>USB jack</li>
  <li>Two LEDs (Power, User)</li>
  <li>Two buttons (Reset, Bootloader/User)</li>
</ul>
</section>


<section><h3>The ATmega32U4 datasheet</h3>
<ul>
  <li class="fragment" data-fragment-index="1">Most important piece of documentation</li>
  <li class="fragment" data-fragment-index="1">433 pages o.O</li>
  <li class="fragment" data-fragment-index="2"><img src="lib/dontpanic.png"></li>
  <li class="fragment" data-fragment-index="3">We will guide you to the relevant parts</li>
  <li class="fragment" data-fragment-index="3">General intro to datasheets will follow later</li>
  <li class="fragment" data-fragment-index="4">Get it here: <a href="http://www.atmel.com/Images/Atmel-7766-8-bit-AVR-ATmega16U4-32U4_%20Datasheet.pdf">bit.ly/1jjFFMb</a> (PDF)<br/>
  <small>(Note: Hover any shortened link to see where it leads)</small></li>
<ul>
</section>

<!--
#######################################################
#######################################################

              MODULE 1: LEDs and I/O

#######################################################
#######################################################
-->


<section id="hello-world"><h3>Module 1</h3>
<h4>Hello, World!</h4>

<p>in which an LED will blink!</p>
<p><div class="component"><img src="lib/tinymega_gon_bon-off.gif"></div></p>
</section>


<section><h3>Stuff you will need</h3>

<p><div class="component">
<img src="lib/usb_cable.png">
<img src="lib/tinymega_goff_boff.png">
</div></p>
</section>


<section><h3>Structure of MCU firmware</h3>
<ul>
<li>It's a program like any other!</li>
<li class="fragment"><code>main()</code> function
  <ul>
    <li>Initialization code</li>
    <li>Main loop</li>
  </ul>
</li>
<li class="fragment">Main loop is never exited</li>
<li class="fragment">avr-libc takes care of the gory stuff</li>
</ul>
</section>


<section><h3>General Purpose I/O</h3>
<ul>
  <li>Most I/O pins of the ATmega can be controlled directly as digital I/O
    <ul>
      <li>Output mode: Write a zero (GND) or one (supply voltage, VDD)</li>
      <li>Input mode: Convert pin voltage to one or zero and return<br/>
          Optional pull-up resistor selectable by software</li>
    </ul>
  </li>
  <li class="fragment">Pins are grouped into "ports"
    <ul>
      <li>ATmega32U4 has ports B, C, D, E, F</li>
      <li>Pins inside a port are numbered 0..7<br/>
          Ex. B1, B2, C7</li>
    </ul>
  </li>
  <li class="fragment">Not all ports have all pins populated</li>
</ul>
</section>


<section><h3>Port control though registers</h3>
<ul>
  <li>All hardware units in AVR MCUs are controlled through memory-mapped registers
    <ul>
      <li>Like special RAM variables</li>
    </ul>
  </li>
  <li class="fragment">Each port has three registers
	<ul><li>
	<table>
	<tr><td>PORTx</td><td>--</td><td>Write output values or enable/disable pull-up</td></tr>
	<tr><td>PINx</td><td>--</td><td>Read input values</td></tr>
	<tr><td>DDRx</td><td>--</td><td>Data Direction Register<br/>selects in (0) / out (1) direction per pin</td></tr>
	</table>
	</li></ul>
  </li>
</ul>
</section>


<section><h3>Port control: Example</h3>
<pre><code data-trim>#include &lt;avr/io.h&gt;

{
	// After reset, all pins default to input, no pull-up
	PORTB = (1 << PB3);		// Enable pull-up on B3
	DDRB = (1 << PB2);		// Set B2 to output, all others to input
	if (!(PINB & _BV(PB3)))		// If something pulls B3 down...
		PORTB |= _BV(PB2);	// Set B2 to high, keep rest as is
}</code></pre>
</section>


<section><h3>Simple delay</h3>
<pre><code data-trim>#define F_CPU 16000000UL  // CPU clock is 16 MHz
#include &lt;util/delay.h&gt;

{
	_delay_ms(1000);  // waaaait a sec...
	_delay_us(10);    // and a bit more
}</code></pre>
</section>

<section><h3>Toolchain installation</h3>
<ul>
  <li>Linux
    <ul>
      <li><pre>apt-get install avr-gcc
apt-get install dfu-programmer</pre></li>
    </ul>
  </li>
  <li>Windows
    <ul>
      <li>AVR 8-bit Toolchain: <a href="http://www.atmel.com/tools/atmelavrtoolchainforwindows.aspx">bit.ly/1gHcJTy</a></li>
      <li>FLIP programmer: <a href="http://www.atmel.com/tools/FLIP.aspx">bit.ly/1hEOZuC</a></li>
      <li>USB driver, if necessary: <a href="http://shackspace.de/wiki/lib/exe/fetch.php?media=project:tinymega:atm32u4dfu.zip">bit.ly/SXghXb</a> (ZIP)</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Template code</h3>
Create a file <code>module1.c</code>:
<pre><code data-trim>#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;

int main(void)
{
	// Setup code goes here
	while (1) {
		// Main loop goes here
	}
}</code></pre>
</section>


<section><h3>Build</h3>
<ul>
  <li>Compile the source
	  <ul>
      <li><pre class="inline">avr-gcc -mmcu=atmega32u4 -DF_CPU=16000000UL \
        -Os -o module1.elf module1.c</pre></li>
    </ul>
  </li>
  <li>Generate an Intel HEX file for flashing
	  <ul>
      <li><pre class="inline">avr-objcopy -O ihex module1.elf module1.hex</pre></li>
    </ul>
  </li>
  <li>Display the firmware size
    <ul>
      <li><pre class="inline">avr-size module1.elf</pre></li>
	    <li><code>text</code> + <code>data</code> is Flash usage</li>
	    <li><code>data</code> + <code>bss</code> is RAM usage</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Program (Linux)</h3>
<p>
<ol>
  <li>Erase the whole device -- bootloader always needs this<br/>
      <pre class="inline">sudo dfu-programmer atmega32u4 erase</pre>
  </li>
  <li class="fragment">Program the HEX file we just generated<br/>
      <pre class="inline">sudo dfu-programmer atmega32u4 flash module1.hex</pre>
  </li>
  <li class="fragment">Have the bootloader jump into the firmware<br/>
      <pre class="inline">sudo dfu-programmer atmega32u4 start</pre>
  </li>
</ol>
<br/><br/>
<span class="fragment">Rumor has it you can save on <pre class="inline">sudo</pre> by adding your user to the <pre class="inline">uucp</pre> group.</span>
</p>
</section>


<section><h3>Program (Windows)</h3>
<img src="lib/flip.png">
<p>Make sure "Reset" is turned off for your first programs</p>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
  <li>Task: Make the user LED on the TinyMega blink with 1 Hz
    <ul>
      <li>(the MCU equivalent of "Hello, World!")</li>
    </ul>
  </li>
  <li class="fragment">Info:
    <ul>
      <li>The LED is connected to pin E6</li>
      <li>Set the pin to 1 to turn on the LED</li>
      <li>Remember to set the pin to output first</li>
      <li>Use a simple delay loop, nothing fancy</li>
      <li>We left a trap for you to discover, so call us if you run into problems ;)</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Base Clock Prescaler</h3>
<ul>
  <li>The ATmega32U4 has an internal clock divider to divide down the external clock.</li>
  <li class="fragment">Example uses:
    <ul>
      <li>Power saving by dynamic frequency switching</li>
      <li>Adapt to lower voltages (only 8 MHz at 3.3V)</li>
    </ul>
  </li>
  <li class="fragment">Trap: Defaults to "divide by 8" in factory settings!</li>
  <li class="fragment">Solution:
  <pre><code data-trim>#include &lt;avr/power.h&gt;
clock_prescale_set(clock_div_1);</code></pre>
  </li>
</ul>
<br/><br/>
</section


<!--
#######################################################
#######################################################

              MODULE 2: Interrupts & Timers

#######################################################
#######################################################
-->


<section id="irq-and-timers"><h3>Module 2</h3>
<h4>Interrupts & Timers</h4>

<p>in which we will waste less CPU cycles!</p>
<p><div class="component"><img src="lib/tinymega_gon_bon-off.gif"></div></p>
</section>


<section><h3>Stuff you will need</h3>
<p><div class="component">
<img src="lib/usb_cable.png">
<img src="lib/tinymega_goff_boff.png">
</div></p>
</section>


<section><h3>Problems with the previous solution</h3>
<ul>
  <li>Hogs CPU cycles ("busy waiting")</li>
  <li>Burns power: CPU constantly busy</li>
  <li>Adding work will make accurate timing difficult/impossible</li>
</ul>
</section>


<section><h3>Solution: Hardware Timers!</h3>
<ul>
  <li>ATmega32U4 has four Timer/Counter (T/C) modules</li>
  <li>HW counter, counting up at (divided) clock frequency</li>
  <li class="fragment">"Compare registers" to trigger actions at certain values</li>
  <li class="fragment">Can also directly control I/O pins, capture event timestamps, ...</li>
</ul>
</section>


<section><h3>Interrupts (IRQs)</h3>
<ul>
  <li>Asynchronous interruption of program flow</li>
  <li>Can happen at any time, triggered by hardware</li>
  <li class="fragment">Many IRQ sources with own handlers
    <ul>
      <li>Timer overflow, Timer compare, Pin toggle, ...</li>
    </ul>
  </li>
  <li class="fragment">Can be enabled / disabled globally
    <ul><li><table>
      <tr><td><code>sei()</code></td><td>-</td><td>SEt Interrupts</td></tr>
	  <tr><td><code>cli()</code></td><td>-</td><td>CLear Interrupts</td></tr>
    </table></li></ul>
  </li>
</ul>
</section>


<section><h3>Interrupt Handlers</h3>
<ul>
  <li>Special function, "called" through interrupt
    <ul>
      <li>Also called "Interrupt Service Routine" (ISR)</li>
      <li>Return from handler continues program</li>
    </ul>
  </li>
</ul>

<br/><br/>
<pre><code data-trim>#include &lt;avr/interrupt.h&gt

ISR(TIMER0_COMPA_vect)
{
	// Code goes here
}</code></pre>
</section>


<section><h3>ISR best practices</h3>
<ul>
  <li>You're just interrupting someone else
    <ul>
      <li>Keep it short!</li>
    </ul>
  </li>
  <li class="fragment">Communication with main loop: shared global variables
    <ul>
      <li>Declare them <code>volatile</code>!
        <ul>
          <li>Tells compiler they may change without notice</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Setting up a Timer/Counter</h3>
<ul>
  <li>Let's look at the datasheet, chapter 14</li>
  <li class="fragment">o.O So many options!<br/>
    Let's pick a few that make sense for us</li>
</ul>
</section>


<section><h3>Choosing a mode</h3>
<ul>
  <li>We want to wait for a given time, generate an IRQ, repeat</li>
  <li class="fragment">CTC mode (14.8.2) sounds like the one for us:
    <ul>
      <li>Count to N, interrupt, start back at zero.</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Choosing a prescaler</h3>
<ul>
  <li>T/C1 can count up to 65535</li>
  <li>We want to wait for half a second</li>
  <li class="fragment">Choose slowest prescaler value of CLK/1024
    <ul>
	  <li>How many ticks per second?</li>
      <li class="fragment">15625 ticks per second</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Building the T/C control registers</h3>
<ul>
  <li>TCCR1A - 14.10.1
    <ul class="fragment">
      <li>We can ignore the Compare Output Modes</li>
      <li>Choose WGM 4: CTC with TOP = OCR1A</li>
    </ul>
  </li>
  <li>TCCR1B - 14.10.3
    <ul class="fragment">
      <li>We can ignore Input Capture</li>
      <li>Clock Select = 0b101 (CLK / 1024)</li>
    </ul>
  </li>
  <li>TCCR1C - 14.10.5
    <ul class="fragment">
      <li>Can be ignored</li>
    </ul>
  </li>  
</ul>
</section>


<section><h3>Building the T/C control registers</h3>
<ul>
  <li>OCR1A - 14.10.9
    <ul class="fragment">
      <li>Determines IRQ frequency</li>
    </ul>
  </li>
  <li>TIMSK1 - 14.10.17
    <ul class="fragment">
      </li>Enable OCIE1A, disable all others</li>
    </ul>
  </li>
  <li>TIFR1 - 14.10.19
    <ul class="fragment">
      <li>Write 0xFF once to clear all pending IRQs</li>
      <li>Just to be safe</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>The setup code</h3>
<pre><code data-trim>#include &lt;avr/io.h&gt;

{
	TCCR1A = 0;
	TCCR1C = 0;
	TCNT1  = 0;
	OCR1A  = 7812;
	TIMSK1 = 1 << OCIE1A;
	TIFR1  = 0xFF;
	// Set TCCR1B last because setting CS starts the T/C
	TCCR1B = (1 << WGM12) | (5 << CS10);
}</code></pre>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
  <li>Task: Transform the busy loop from module 1 into a timer-driven blinking LED.
    <ul>
      <li><pre class="inline">cp module1.c module2.c</pre></li>
    </ul>
  </li>
  <li class="fragment">Info:
    <ul>
      <li>Use T/C 1 in CTC mode</li>
      <li>Remember to enable interrupts after setup</li>
    </ul>
  </li>
  <li class="fragment">Question:
    <ul>
      <li>Which interrupt to hook?</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Tips & Tricks</h3>
<ul>
  <li>Toggle a port pin value by writing PINx:
	<ul>
		<li><pre class="inline"><code data-trim>PINE = 1 << PE6;</code></pre></li>
		<li>Little known AVR feature</li>
	</ul>
  </li>
  <li>Save power by using Sleep Mode in main loop
    <ul>
      <li>Chapter 7 of datasheet<br/>
        avr-libc sleep mode documentation: <a href="http://www.nongnu.org/avr-libc/user-manual/group__avr__sleep.html">bit.ly/1ttg2hR</a>
      </li>
    </ul>
  </li>
</ul>
</section>



<!--
#######################################################
#######################################################

                 MODULE 3

#######################################################
#######################################################
-->
<section id="leds-and-io"><h3>Module 3</h3>
<h4>LEDs & I/O</h4>
<p>in which we will revive K.I.T.T.!</p>
<p><div class="component"><img src="lib/larson_8.gif"></div></p>
</section>


<section><h3>Stuff you will need</h3>
<p><div class="component">
<div style="width: 200px"><img src="lib/usb_cable.png"></div>
<div style="width: 200px"><img src="lib/tinymega_goff_boff.png"></div>
<div style="width: 200px"><img src="lib/breadboard.png"></div><br/>
<div style="width: 200px"><img src="lib/jumper_wire.png"><br/>several</div>
<div style="width: 200px"><img src="lib/led_red.png"><br/>8x</div>
<div style="width: 200px"><img src="lib/resistor.png"><br/>8x</div>
</div></p>
</section>


<section><h3>LED basics</h3>
<ul>
	<li>An LED's brightness depends on current</li>
	<li>Typical I<sub>F</sub>: 20 mA</li>
	<li>Let's check the datasheet for the expected V<sub>F</sub></li>
</ul>
</section>


<section><h3>Datasheets</h3>
<ul>
	<li>Typical sections:
		<ol>
			<li>Summary, core features and values</li>
			<li>Basic operation</li>
			<li>Absolute Maximum Ratings</li>
			<li>Device characteristics
				<ul>
					<li>Tables with min/typ/max values</li>
					<li>Graphs</li>
				</ul>
			</li>
			<li>Detailed usage information</li>
			<li>Example application circuits</li>
			<li>Test circuits used</li>
			<li>Package information, solder patterns</li>
			<li>Order information, revisions, disclaimers</li>
		</ol>
	</li>
	
</ul>
</section>


<section><h3>Our LED</h3>
<ul>
	<li>I<sub>F</sub> = 20 mA</li>
	<li>V<sub>F</sub> = 1.8 V</li>
	<li><i class="fa fa-arrow-right"></i> R = (V<sub>DD</sub> - V<sub>F</sub>) / I<sub>F</sub> = 160 &Omega;</li>
	<li>Pick next higher standard value: 180 &Omega;</li>
</ul>
</section>


<section><h3>Recommended coding</h3>
<ul>
	<li>Build upon your code from last module
		<ul>
			<li>Change OCR1A to go faster</li>
		</ul>
	</li>
	<li>Connect all LEDs to pins of the same port
		<ul>
			<li>One assignment to set them all</li>
		</ul>
	</li>
</ul>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
	<li>Task: Implement a Larson Scanner
		<ul>
			<li><pre><code>cp module2.c module3.c</code></pre></li>
		</ul>
	</li>
	<li>Info:
		<ul>
			<li>Remember correct port setup</li>
		</ul>
	</li>
</ul>
</section>


<!--
#######################################################
#######################################################

                 MODULE 4

#######################################################
#######################################################
-->

<section id="button-control"><h3>Module 4</h3>
  <h4>Button Control</h4>
  <p>in which we will succumb to force!</p>
  <p><img src="lib/larson_8.gif"></p>
</section>



<section><h3>Stuff you will need</h3>
<p><div class="component">
<div style="width: 200px"><img src="lib/usb_cable.png"></div>
<div style="width: 200px"><img src="lib/tinymega_goff_boff.png"></div>
<div style="width: 200px"><img src="lib/breadboard.png"></div>
<div style="width: 200px"><img src="lib/button.png"></div><br/>
<div style="width: 200px"><img src="lib/jumper_wire.png"><br/>several</div>
<div style="width: 200px"><img src="lib/led_red.png"><br/>8x</div>
<div style="width: 200px"><img src="lib/resistor.png"><br/>8x</div>
</div></p>
</section>



<section><h3>Add a button!</h3>
<ul>
  <li>Button will usually connect A to B when pressed
    <ul>
      <li>"Single Pole, Single Throw" - SPST</li>
	  <li><table>
		<tr><td>Pole</td><td><i class="fa fa-arrow-right"></i></td><td>number of "channels"</td></tr>
		<tr><td>Throw</td><td><i class="fa fa-arrow-right"></i></td><td>number of positions per channel</td></tr>
	  </table></li>
    </ul>
  </li>
  <li>Idea: Press to connect input pin to VDD
    <ul>
      <li>But what happens while not pressed?</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>High-Z / floating state</h3>
<ul>
        <li>Pins that are not connected anywhere
          <ul>
            <li>Called "floating"</li>
            <li>Or High-Z for "high resistance to anywhere"</li>
          </ul>
        </li>
        <li>A floating input will read random values!
          <ul><li>Collects charge though static and ambient noise</li></ul>
        </li>
        <li>Solution: Remove the High-Z condition
          <ul><li>by adding a low-Z path.</li></ul>
        </li>
</ul>
</section>



<section><h3>Pull-up / Pull-down resistors</h3>
<ul>
        <li>Provide a path from pin to defined voltage (VDD, GND)
		  <ul>
			<li>Neither a short circuit nor High-Z</li>
            <li>Typical resistor value: around 10k&Omega;</li>
		  </ul>
        </li>
        <li class="fragment">Pulls floating pin up to VDD or down to GND
        <ul>
          <li>Can be easily overcome by a short circuit, e.g. a button</li>
          <li>SC creates negligible current while pushed -- 0.5 mA for 10k&Omega;, 5V</li>
        </ul>
        </li>
        <li class="fragment">Like a water reservoir (think flush toilet)
          <ul>
            <li>Water level is pin voltage</li>
            <li>Pull-Up is water supply with valve</li>
            <li>Button is big flush valve</li>
         </ul>
        </li>
</ul>
</section>


<section><h3>Full circuit</h3>
<ul>
        <li>Either pull-down with button to VDD or pull-up with button to GND
          <ul><li>Which one should we use?</li></ul>
        </li>
        <li class="fragment" data-fragment-index="2">Reminder: ATmega pins have optional internal pull-up!
          <ul><li>So choose pull-up with button to GND</li></ul>
        </li>
        <li class="fragment" data-fragment-index="2">Switch pin to input + pull-up
          <ul><li>If we read a <em>zero</em>, the button is <em>pressed</em></li></ul>
        </li>
</ul>
</section>



<section><h3>Level triggered vs. edge triggered</h3>
<ul>
        <li>We will poll the button in our main loop</li>
        <li>Options:
          <ol class="alpha">
            <li>Do something whenever polling returns "pushed"
            <ul>
              <li>Will do something every iteration</li>
              <li>"Level triggered"</li>
            </ul>
            </li>
            <li>Do something when button goes from "not pushed" to "pushed"
            <ul>
              <li>Will do something once per button push-release cycle</li>
              <li>"Edge triggered"</li>
            </ul>
            </li>
          </ol>
        </li>
</ul>
</section>



<section><h3>Now go forth and code!</h3>
<ul>
        <li>Task: Advance Larson Scanner manually instead of timer
        <ul><li><pre class="inline"><code>cp module5.c module6.c</code></pre></li></ul>
        </li>
        <li>Info:
          <ul>
            <li>Don't throw away the timer code, just turn off timer</li>
            <li>Move main Larson code into own function</li>
            <li>Poll button in main loop, edge trigger Larson code</li>
            <li>Remember to switch pin to input + pull-up</li>
            <li>We have left a trap for you -- if anything's weird, please speak up!</li>
          </ul>
        </li>
</ul>
</section>



<section><h3>Button contact "bouncing"</h3>
<ul>
        <li>Buttons have mechanical contacts that are not perfect
          <ul>
            <li>When pushed, will bounce ever so slightly</li>
            <li>Causes short on-off-on-off-... sequence</li>
            <li>Will settle into permanent "on" after a short time</li>
          </ul>
        </li>
        <li>Trap: If polling code is fast enough, it will see this!
          <ul><li>Will interpret as several very fast pushes</li></ul>
        </li>
        <li>Only a problem with edge triggering</li>
</ul>

<aside class="notes">Hier kann man aufm Oszi zeigen, wie ein Taster prellt</aside>
</section>



<section><h3>Debouncing techniques</h3>
<ul>
        <li>Analog filter (lowpass)
          <ul><li>Will smooth out button signal, needs hardware</li></ul>
        </li>
        <li>Digital filtering
          <ul>
            <li>Keep history of last N measurements</li>
            <li>Require all measurements to agree</li>
          </ul>
        </li>
        <li>Slower polling (if possible)
          <ul>
            <li>Bouncing will disappear in time between polls</li>
            <li>Easiest solution</li>
          </ul>
        </li>
</ul>
</section>



<section><h3>Now go forth and code!</h3>
<ul>
        <li>Task: Debounce your button</li>
        <li>Info:
          <ul>
            <li>Use the same source file</li>
            <li>Your choice: digital filter or slower polling</li>
          </ul>
        </li>
</ul>
</section>



<section><h3>Further reading</h3>
<p>ATmega has ways of causing interrupts when an input changes</p>
<ul>
        <li>Pin Change Interrupt
        <ul><li>Triggers on any change</li></ul></li>
        <li>External Interrupt
        <ul><li>Trigger on rising edge, falling edge, or low level</li></ul></li>
        <li>Check out datasheet chapter 11 for details</li>
</ul>
</section>



<!--
#######################################################
#######################################################

                 MODULE 5

#######################################################
#######################################################
-->


<section id="extending-io"><h3>Module 5</h3>
<h4>Extending your I/O</h4>	
<p>in which three pins will control 16 LEDs!</p>
<p><div class="component"><img src="lib/larson_16.gif"></div></p>
</section>


<section><h3>Stuff you will need</h3>
<p><div class="component">
<div style="width: 200px"><img src="lib/usb_cable.png"></div>
<div style="width: 200px"><img src="lib/tinymega_goff_boff.png"></div>
<div style="width: 200px"><img src="lib/breadboard.png"></div><br/>
<div style="width: 200px"><img src="lib/jumper_wire.png"><br/>several</div>
<div style="width: 200px"><img src="lib/led_red.png"><br/>16x</div>
<div style="width: 200px"><img src="lib/resistor.png"><br/>16x</div>
<div style="width: 200px"><img src="lib/DIP16.png"><br/>2x</div>
</div></p>
</section>


<section><h3>What's a shift register?</h3>
<ul>
	<li>Converts serial data to parallel data or vice versa</li>
	<li>Data is shifted in/out bit by bit
		<ul>
			<li>A clock signal triggers a single shift</li>
		</ul>
	</li>
	<li>Our device: Serial in, parallel out (SIPO)</li>
	<li>Latched: Outputs kept static while new data shifted in
		<ul>
			<li>Latch signal changes all outputs at once</li>
		</ul>
	</li>
</ul>
</section>


<section><h3>How do I use a SIPO shift reg?</h3>
<pre><code>for (i = 0 .. number of bits) {
	set data input pin to next bit
		(starting with outermost bit)
	pulse clock pin
}
pulse latch pin</code>
</pre>
</section>


<section><h3>Daisy Chaining</h3>
<ul>
	<li>A shift reg usually also has a serial output pin</li>
	<li>Can be used as input for another shift reg</li>
	<li>Clock and latch pins can be tied together</li>
	<li>Infinite shift register! \o/</li>
</ul>
</section>



<section><h3>SN74HC595</h3>
<ul>
	<li>Part of the 74xxx series of standard logic (<a href="https://en.wikipedia.org/wiki/74_series">bit.ly/SaEU1L</a>)
		<ul>
			<li>Lots and lots and lots of parts available (<a href="https://en.wikipedia.org/wiki/List_of_7400_series_integrated_circuits">bit.ly/SwsD89</a>)</li>
			<li>From every vendor</li>
		</ul>
	</li>
	<li>VV74SSNNN
		<ul>
			<li>VV - Vendor, e.g. SN for Texas Instruments</li>
			<li>SS - Series, e.g. HC for High-Speed CMOS</li>
			<li>NNN - Device ID, 595 is latched SIPO</li>
		</ul>
	</li>
</ul>
</section>



<section><h3>Circuit building</h3>
<ul>
	<li>Get the datasheet (<a href="http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf">bit.ly/UdZpfR</a>, PDF)
	<li>Put the two 74HC595 onto the breadboard
		<ul>
			<li>Connect their VDD and GND pins</li>
			<li>Tie both <span class="overbar">MR</span> pins to VDD</li>
			<li>Connect DS of the first to a TinyMega pin</li>
			<li>Connect DS of the second to Q7S of the first</li>
			<li>Connect both SHCP pins to a second TinyMega pin</li>
			<li>Connect both STCP pins to a third TinyMega pin</li>
		</ul>
	</li>
	<li>Now place LEDs and resistors</li>
</ul>
</section>



<section><h3>Now go forth and code!</h3>
<ul>
	<li>Task: Transform the Larson Scanner to use SIPO
		<ul>
			<li><pre><code>cp module3.c module4.c</code></pre></li>
		</ul>
	</li>
	<li>Info:
		<ul>
			<li>Use a two-byte buffer for the LED states</li>
			<li>Shift that buffer out to the SIPO</li>
			<li>Use a simple loop, don't try to be smart</li>
		</ul>
	</li>
	<li>Question:
		<ul>
			<li>Do you need delays between bits?</li>
		</ul>
	</li>
</ul>
</section>


<!--
#######################################################
#######################################################

                 MODULE 6

#######################################################
#######################################################
-->
<section id="spi"><h3>Module 6</h3>
<h4>SPI - HW serial data</h4>
<p>in which a loop will move into hardware!</p>
<p><div class="component"><img src="lib/larson_16.gif"></div></p>
</section>


<section><h3>Stuff you will need</h3>
<p><div class="component">
<div style="width: 200px"><img src="lib/usb_cable.png"></div>
<div style="width: 200px"><img src="lib/tinymega_goff_boff.png"></div>
<div style="width: 200px"><img src="lib/breadboard.png"></div><br/>
<div style="width: 200px"><img src="lib/jumper_wire.png"><br/>several</div>
<div style="width: 200px"><img src="lib/led_red.png"><br/>16x</div>
<div style="width: 200px"><img src="lib/resistor.png"><br/>16x</div>
<div style="width: 200px"><img src="lib/DIP16.png"><br/>2x</div>
</div></p>
</section>


<section><h3>Bit-banging</h3>
<ul>
	<li>Common term in embedded programming</li>
	<li>Operating bit protocol by toggling pins in software</li>
	<li>Con: Not very hardware efficient</li>
	<li>Pro: Any protocol can be implemented</li>
</ul>
</section>


<section><h3>What is SPI?</h3>
<ul>
	<li>"Serial Peripheral Interface"</li>
	<li>Basically a daisy chain of shift registers</li>
	<li>"Master" drives the chain, supplies the clock</li>
	<li>"Slaves" only react</li>
	<li>Last slave output may go back into the uC for return data</li>
	<li>No defined protocol for actual data
		<ul>
			<li>Device datasheets will tell</li>
		</ul>
	</li>
</ul>
</section>


<section><h3>SPI signals</h3>
<ul>
	<li>MOSI - Master Out / Slave In</li>
	<li>MISO - Master In / Slave Out</li>
	<li>SCK  - Serial Clock</li>
	<li>SS   - Slave Select (optional)</li>
</ul>
</section>


<section><h3>SPI applications</h3>
<ul>
	<li>Control any number of SPI slaves</li>
	<li>Generally, shift out serial data with clock</li>
	<li>We can use this for our SIPO shift regs!</li>
</ul>
</section>


<section><h3>SPI capabilities in the ATmega</h3>
<ul>
	<li>Both master and slave mode supported</li>
	<li>LSB-first and MSB-first modes</li>
	<li>Four kinds of CLK vs. data relationships (17.2)
		<ul>
			<li>Low-active vs. high-active clock</li>
			<li>Sample on leading or trailing edge of clock</li>
		</ul>
	</li>
	<li>Interrupt on byte completion</li>
</ul>
</section>


<section><h3>SPI pins on the ATmega</h3>
<ul>
	<li>SPI pins mapped to fixed port pins
		<ul>
			<li>Other MCUs are more flexible</li>
		</ul>
	</li>
	<li>Trap: Be careful what you use the SS pin for!
		<ul>
			<li>Could abort transmission in Master mode (17.1.2)</li>
		</ul>
	</li>
	<li>Pin data controlled by HW</li>
	<li>FW responsible for setting up pin direction!</li>
</ul>
</section>


<section><h3>Setting up the SPI controller</h3>
<ul>
	<li>SPCR - SPI Control Reg (17.1.3)
		<ul>
			<li>Most bits are obvious, but:</li>
			<li>Data order?</li>
			<li>Clock polarity?</li>
			<li>Clock phase?</li>
		</ul>
	</li>
	<li>SPSR - SPI Status Reg (17.1.4)
		<ul>
			<li>Read before first writing SPDR</li>
			<li>Clears any pending interrupts</li>
		</ul>
	</li>
</ul>
</section>

	
<section><h3>SPI transmission</h3>
<ul>
	<li>SPDR - SPI Data Reg (17.1.5)
		<ul>
			<li>Write data here</li>
			<li>Don't write again until byte finished</li>
		</ul>
	</li>
	<li>Handle next byte(s) in SPI interrupt
		<ul>
			<li>Use volatile data pointer</li>
			<li>Write next byte to SPDR</li>
			<li>When transfer finished
				<ul>
					<li>Disable SPI to be safe</li>
					<li>Strobe LATCH signal</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
</section>


<section><h3>Debugging technique</h3>
<ul>
	<li>Use unused pin as debug signal</li>
	<li>Set / reset on given events</li>
	<li>Watch on oscilloscope to:
		<ul>
			<li>Measure signal timing</li>
			<li>Find out time taken by code</li>
			<li>Trigger on sporadic events</li>
		</ul>
	</li>
</ul>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
	<li>Task: Transform SIPO code from bit-banging to SPI
		<ul>
			<li><pre><code>cp module4.c module5.c</code></pre></li>
		</ul>
	</li>
	<li>Info:
		<ul>
			<li>Make sure you use the correct pins</li>
			<li>Remember to set up pin directions</li>
			<li>Start SPI xfer on timer IRQ</li>
			<li>Keep SPI running through SPI IRQ</li>
		</ul>
	</li>
</ul>
</section>


<!--
#######################################################
#######################################################

                 META INFORMATION

#######################################################
#######################################################
-->

<section id="meta"><h3>Meta Information</h3>
  <ul>
    <li>Slides: <a href="https://github.com/shackspace/uc-basics">github.com/shackspace/uc-basics</a></li>
    <li>Datasheets
      <ul>
        <li>Microcontroller (ATmega23U4): <a href="http://www.atmel.com/Images/Atmel-7766-8-bit-AVR-ATmega16U4-32U4_%20Datasheet.pdf">bit.ly/1jjFFMb</a> (PDF)</li>
        <li>LED</li>
        <li>Shift Register (74595): <a href="http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf">bit.ly/UdZpfR</a> (PDF)</li>
      </ul>
    </li>
    <li>Contact Info
      <ul>
        <li>Joachim Fenkes<br/>
        @dop3j0e, github.com/dop3j0e, uc-basics@dojoe.net</li>
        <li>Gregor Jehle<br/>
        @hdznrrd, github.com/hdznrrd, uc-basics@follvalsch.de</li>
      </ul>
    </li>
  </ul>
</section>

<section><h3>Source Attribution</h3>
<div class="attribution">
<ul>
  <li>Samsung Crystal Blue washing machine, CC-BY-NC-SA Samsung Tomorrow, 2015-05-14 15:31, https://www.flickr.com/photos/samsungtomorrow/14180614352/</li>
  <li>Rancilio coffee machine, CC-BY-NC Faye Yu, 2014-05-14 15:42, https://www.flickr.com/photos/fayeyu/7776398/</li>
  <li>Samsung Stainless Steel microwave oven, CC-BY-NC-SA Samsung Tomorrow, 2015-05-14 15:47, https://www.flickr.com/photos/samsungtomorrow/7792317532/</li>
  <li>Atmel ATmega32U4 Block Diagram, &copy; 2014 Atmel Corporation, 2015-05-28 15:00, Atmel-7766G-AVR-ATmega16U4-32U4-Datasheet_02/2014</li>
</ul>
</div>
</section>
</div> <!-- slides -->
</div> <!-- reveal -->

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>
<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: false,
    progress: true,
    history: true,
    center: true,

    theme: 'night',
    transition: 'none',

    // Optional libraries used to extend on reveal.js
    dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ]
  });
</script>
</body>
</html>
