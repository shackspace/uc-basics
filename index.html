<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Introduction to Microcontroller Programming</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/default.css" id="theme">
  <link rel="stylesheet" href="lib/css/zenburn.css">
  <link rel="stylesheet" href="lib/font-awesome-4.1.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="css/itmp.css">
  <!--[if lt IE 9]><script src="lib/js/html5shiv.js"></script><![endif]-->
</head>
<body>
<div class="reveal">
<div id="staticnav">
  <i class="fa fa-bars fa-2x"></i>
  <br />
  <ul>
    <li><a href="#/introduction">Introduction</a></li>
    <li><a href="#/hello-world">Module 1: Hello, World!</a></li>
    <li><a href="#/irq-and-timers">Module 2: Interrupts &amp; Timers</a></li>
    <li><a href="#/leds-and-io">Module 3: LEDs &apm; I/O</a></li>
    <li><a href="#/extending-io">Module 4: Extending your I/O</a></li>
    <li><a href="#/spi">Module 5: SPI - HW Serial Data</a></li>
    <li><a href="#/knob-control">Module 6: Knob Control</a></li>
    <li><a href="#/digital-dimming">Module 7: Dimming Stuff Digitally</a></li>
    <li><a href="#/moodlight">Module 8: RGB Moodlight</a></li>
    <li><a href="#/wrapping-up">Wrapping Up</a></li>
    <li><a href="#/meta">Meta Information</a></li>
  </ul>
</div>

<!--
#######################################################
#######################################################

                        PRELUDE

#######################################################
#######################################################
-->


<div class="slides">
<section><h3>Introduction to Microcontroller Programming</h3>
  <h4>using an Atmel ATmega32U4</h4>
  <div>
    <p>Joachim Fenkes (@dop3j0e)</p>
    <p>Gregor Jehle (@hdznrrd)</p>
  </div>
  <img src="lib/ccbyncsa.png">
</section>

<section><h3>Today's Goals</h3>
<ul class="fragment">
  <li>Understand
    <ul class="fragment">
      <li>Microcontroller programming basics</li>
      <li>I/O and Hardware assist units</li>
      <li>Basic external peripherals</li>
      <li>Reading Datasheets</li>
    </ul>
  </li>
  <li>Implement
    <ul class="fragment">
      <li>Hello World</li>
      <li>LED Larson Scanner</li>
      <li>Knob control</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>Who we are</h3>
<ul>
  <li>Joachim "Jocki" Fenkes
    <ul>
      <li>created the board we're using today</li>
    </ul>
  </li>

  <li>Gregor "hadez" Jehle
    <ul>
      <li>programs MCUs for a living</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Who are you?</h3>
<ul>
  <li>Please introduce yourselves with
	  <ul>
      <li>Your name</li>
	    <li><em>One</em> sentence about your prior knowledge with microcontrollers</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>Dedicated to</h3>
Jan-Bernd Themann<br/>
R.I.P., my friend
</section>

<!--
#######################################################
#######################################################

                    INTRODUCTION

#######################################################
#######################################################
-->

<section id="introduction"><h3>What is a Microcontroller?</h3>

"A microcontroller [...] is a <strong>small computer on a single integrated circuit</strong> containing a processor core, memory, and programmable input/output peripherals. Program memory [...] is also often included on chip, as well as a typically small amount of RAM. Microcontrollers are <strong>designed for embedded applications</strong> [...]" (Source: <a href="http://en.wikipedia.org/w/index.php?title=Microcontroller&oldid=607593541">Wikipedia</a>)
</section>


<section><h3>Applications</h3>
<div style="width: 300px" class="photowrapper"><img src="lib/ranciliocoffeemachine.jpg">CC-BY-NC Faye Yu</div>
<div style="width: 300px" class="photowrapper"><img src="lib/samsungcrystalblue.jpg">CC-BY-NC-SA Samsung Tomorrow</div>
<div style="width: 300px" class="photowrapper"><img src="lib/samsungmicrowave.jpg">CC-BY-NC-SA Samsung Tomorrow</div>
</section>


<section><h3>Typical block diagram</h3>
<img src="lib/uc_blockdiagram.png">
</section>


<section><h3>Limitations</h3>
<ul>
  <li class="fragment" data-fragment-index="1">A uC ain't a PC!</li>
  <li class="fragment" data-fragment-index="1">Optimized for low power and size</li>
  <li class="fragment" data-fragment-index="1">Slow compared to a PC or a smartphone</li>
  <li class="fragment" data-fragment-index="2">Little RAM</li>
  <li class="fragment" data-fragment-index="2">No floating point unit</li>
  <li class="fragment" data-fragment-index="2">Sometimes not even HW multiplication</li>
</ul>
</section>


<section><h3>Our learning modules today</h3>
<ol>
  <li class="fragment">Hello, World!</li>
  <li class="fragment">Interrupts & Timers</li>
  <li class="fragment">LEDs & I/O</li>
  <li class="fragment">Extending your I/O</li>
  <li class="fragment">SPI - HW serial data</li>
  <li class="fragment">Knob Control</li>
  <li class="fragment">Dimming stuff digitally</li>
  <li class="fragment">(optional) Building an RGB Moodlight</li>
</ol>
</section>


<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus_cpu.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus_cpu_peri.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus_cpu_peri_gpio.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_bus_cpu_peri_gpio_annotated.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_blockdiagram_annotated_color.png">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/atmega32u4_blockdiagram.png">
</section>


<section><h3>The TinyMega Board</h3>
<ul>
  <li>The MCU itself</li>
  <li>Clock crystal (16 MHz)</li>
  <li>USB jack</li>
  <li>Two LEDs (Power, User)</li>
  <li>Two buttons (Reset, Bootloader/User)</li>
</ul>
</section>


<section><h3>The ATmega32U4 datasheet</h3>
<ul>
  <li class="fragment" data-fragment-index="1">Most important piece of documentation</li>
  <li class="fragment" data-fragment-index="1">433 pages o.O</li>
  <li class="fragment" data-fragment-index="2"><img src="lib/dontpanic.png"></li>
  <li class="fragment" data-fragment-index="3">We will guide you to the relevant parts</li>
  <li class="fragment" data-fragment-index="3">General intro to datasheets will follow later</li>
  <li class="fragment" data-fragment-index="4">Get it here: <a href="http://bit.ly/1jjFFMb">bit.ly/1jjFFMb</a></li>
<ul>
</section>

<!--
#######################################################
#######################################################

              MODULE 1: LEDs and I/O

#######################################################
#######################################################
-->


<section id="hello-world"><h3>Module 1</h3>
<h4>Hello, World!</h4>

<p>in which an LED will blink!</p>
<p><div class="component"><img src="lib/tinymega_gon_bon-off.gif"></div></p>
</section>


<section><h3>Stuff you will need</h3>

<p><div class="component">
<img src="lib/usb_cable.png">
<img src="lib/tinymega_goff_boff.png">
</div></p>
</section>


<section><h3>Structure of MCU firmware</h3>
<p>
It's a program like any other!

<ul>
  <li><pre class="inline">main()</pre> function
    <ul>
      <li>Initialization code</li>
      <li>Main loop</li>
    </ul>
  </li>
  <li>Main loop is never exited</li>
</ul>
</p>
</section>


<section><h3>General Purpose I/O</h3>
<ul>
  <li>Most I/O pins of the ATmega can be controlled directly as digital I/O
    <ul>
      <li>Output mode: Write a zero (GND) or one (supply voltage, VDD)</li>
      <li>Input mode: Convert pin voltage to one or zero and return<br/>
          Optional pull-up resistor selectable by software</li>
    </ul>
  </li>
  <li>Pins are grouped into "ports"
    <ul>
      <li>ATmega32U4 has ports B, C, D, E, F</li>
      <li>Pins inside a port are numbered 0..7<br/>
          Ex. B1, B2, C7</li>
    </ul>
  </li>
  <li>Not all ports have all pins populated</li>
</ul>
</section>


<section><h3>Port control though registers</h3>
<ul>
  <li>All hardware units in AVR MCUs are controlled through memory-mapped registers
    <ul>
      <li>Like special RAM variables</li>
    </ul>
  </li>
  <li>Each port has three registers
    <ul>
      <li>PORTx -- Write output values or enable/disable pull-up</li>
      <li>PINx  -- Read input values</li>
      <li>DDRx  -- Data Direction Register; selects in (0) / out (1) direction per pin</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Port control: Example</h3>
<pre><code data-trim>#include &lt;avr/io.h&gt;

{
	// After reset, all pins default to input, no pull-up
	PORTB = (1 << PB3);		// Enable pull-up on B3
	DDRB = (1 << PB2);		// Set B2 to output, all others to input
	if (!(PINB & _BV(PB3)))		// If something pulls B3 down...
		PORTB |= _BV(PB2);	// Set B2 to high, keep rest as is
}</code></pre>
</section>


<section><h3>Simple delay</h3>
<pre><code data-trim>#define F_CPU 16000000UL  // CPU clock is 16 MHz
#include &lt;util/delay.h&gt;

{
	_delay_ms(1000);  // waaaait a sec...
	_delay_us(10);    // and a bit more
}</code></pre>
</section>

<section><h3>Toolchain installation</h3>
<ul>
  <li>Linux
    <ul>
      <li><pre>apt-get install avr-gcc dfu-programmer</pre></li>
    </ul>
  </li>
  <li>Windows
    <ul>
      <li><a href="http://www.atmel.com/tools/atmelavrtoolchainforwindows.aspx">AVR 8-bit Toolchain</a></li>
      <li><a href="http://www.atmel.com/tools/FLIP.aspx">FLIP programmer</a></li>
      <li><a href="http://shackspace.de/wiki/lib/exe/fetch.php?media=project:tinymega:atm32u4dfu.zip">USB driver</a> (if necessary)</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Template code</h3>
Create a file <code>module1.c</code>:
<pre><code data-trim>#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;

int main(void)
{
	// Setup code goes here
	while (1) {
		// Main loop goes here
	}
}</code></pre>
</section>


<section><h3>Build</h3>
<ul>
  <li>Compile the source
	  <ul>
      <li><pre class="inline">avr-gcc -mmcu=atmega32u4 -DF_CPU=16000000UL \
        -Os -o module1.elf module1.c</pre></li>
    </ul>
  </li>
  <li>Generate an Intel HEX file for flashing
	  <ul>
      <li><pre class="inline">avr-objcopy -O ihex module1.elf module1.hex</pre></li>
    </ul>
  </li>
  <li>Display the firmware size
    <ul>
      <li><pre class="inline">avr-size module1.elf</pre></li>
	    <li><pre class="inline">text + data</pre> is Flash usage</li>
	    <li><pre class="inline">data + bss</pre> is RAM usage</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Program (Linux)</h3>
<p>
<ol>
  <li>Erase the whole device -- bootloader always needs this<br/>
      <pre class="inline">sudo dfu-programmer atmega32u4 erase</pre>
  </li>
  <li>Program the HEX file we just generated<br/>
      <pre class="inline">sudo dfu-programmer atmega32u4 flash module1.hex</pre>
  </li>
  <li>Have the bootloader jump into the firmware<br/>
      <pre class="inline">sudo dfu-programmer atmega32u4 start</pre>
  </li>
</ol>
<br/><br/>
Rumor has it you can save on <pre class="inline">sudo</pre> by adding your user to the <pre class="inline">uucp</pre> group.
</p>
</section>


<section><h3>Program (Windows)</h3>
<img src="lib/flip.png">
</section>


<section><h3>Now go forth and code!</h3>
<ul>
  <li>Task: Make the user LED on the TinyMega blink with 1 Hz
    <ul>
      <li>(the MCU equivalent of "Hello, World!")</li>
    </ul>
  </li>
  <li>Info:
    <ul>
      <li>The LED is connected to pin E6</li>
      <li>Set the pin to 1 to turn on the LED</li>
      <li>Remember to set the pin to output first</li>
      <li>Use a simple delay loop, nothing fancy</li>
      <li>We left a trap for you to discover, so call us if you run into problems ;)</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Base Clock Prescaler</h3>
<ul>
  <li>The ATmega32U4 has an internal clock divider to divide down the external clock.</li>
  <li>Example uses:
    <ul>
      <li>Power saving by dynamic frequency switching</li>
      <li>Adapt to lower voltages (only 8 MHz at 3.3V)</li>
    </ul>
  </li>
  <li>Trap: Defaults to "divide by 8" in factory settings!</li>
  <li>Solution:
  <pre><code data-trim>#include &lt;avr/power.h&gt;
clock_prescale_set(clock_div_1);</code></pre>
  </li>
</ul>
<br/><br/>
</section


<!--
#######################################################
#######################################################

              MODULE 1: LEDs and I/O

#######################################################
#######################################################
-->


<section><h3>Module 2</h3>
<h4>Interrupts & Timers</h4>

in which we will waste less CPU cycles!

[gif: blinkender tinymega]
</section>


<section><h3>Stuff you will need</h3>
<p><div class="component">
<img src="lib/usb_cable.png">
<img src="lib/tinymega_goff_boff.png">
</div></p>
</section>


<section><h3>Problems with the previous solution</h3>
<ul>
  <li>Hogs CPU cycles ("busy waiting")</li>
  <li>Burns power: CPU constantly busy</li>
  <li>Adding work will make accurate timing difficult/impossible</li>
</ul>
</section>


<section><h3>Solution: Hardware Timers!</h3>
<ul>
  <li>ATmega32U4 has four Timer/Counter (T/C) modules</li>
  <li>HW counter, counting up at (divided) clock frequency</li>
  <li>Compare registers to trigger actions at certain values</li>
  <li>Can also directly control I/O pins, capture event timestamps, ...</li>
</ul>
</section>


<section><h3>Interrupts (IRQs)</h3>
<ul>
  <li>Asynchronous interruption of program flow</li>
  <li>Can happen at any time, triggered by hardware</li>
  <li>Many IRQ sources with own handlers
    <ul>
      <li>Timer overflow, Timer compare, Pin toggle, ...</li>
    </ul>
  </li>
  <li>Can be enabled / disabled globally
    <ul>
      <li><pre class="inline">sei()</pre>, <pre class="inline">cli()</pre></li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Interrupt Handlers</h3>
<ul>
  <li>Special function, "called" through interrupt
    <ul>
      <li>Also called "Interrupt Service Routine" (ISR)</li>
      <li>Return from handler continues program</li>
    </ul>
  </li>
</ul>

<br/><br/>
<pre><code data-trim>#include &lt;avr/interrupt.h&gt

ISR(TIMER0_COMPA_vect)
{
	// Code goes here
}</code></pre>
</section>


<section><h3>ISR best practices</h3>
<ul>
  <li>You're just interrupting someone else
    <ul>
      <li>Keep it short!</li>
    </ul>
  </li>
  <li>Communication with main loop: shared global variables
    <ul>
      <li>Declare them <code>volatile</code>!
        <ul>
          <li>Tells compiler they may change without notice</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Setting up a Timer/Counter</h3>
<p>Let's look at the datasheet, chapter 14</p>

<p>o.O So many options!<br/>
Let's pick a few that make sense for us</p>
</section>


<section><h3>Choosing a mode</h3>
<ul>
  <li>We want to wait for a given time, generate an IRQ, repeat</li>
  <li>CTC mode (14.8.2) sounds like the one for us:
    <ul>
      <li>Count to N, interrupt, start back at zero.</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Choosing a prescaler</h3>
<ul>
  <li>T/C1 can count up to 65535</li>
  <li>We want to wait for half a second</li>
  <li>Choose slowest prescaler value of CLK/1024
    <ul>
      <li>15625 ticks per second</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Building the T/C control registers</h3>
<ul>
  <li>TCCR1A - 14.10.1
    <ul>
      <li>We can ignore the Compare Output Modes</li>
      <li>Choose WGM 4: CTC with TOP = OCR1A</li>
    </ul>
  </li>
  <li>TCCR1B - 14.10.3
    <ul>
      <li>We can ignore Input Capture</li>
      <li>Clock Select = 0b101 (CLK / 1024)</li>
    </ul>
  </li>
  <li>TCCR1C - 14.10.5
    <ul>
      <li>Can be ignored</li>
    </ul>
  </li>  
</ul>
</section>


<section><h3>Building the T/C control registers</h3>
<ul>
  <li>OCR1A - 14.10.9
    <ul>
      <li>Determines IRQ frequency</li>
    </ul>
  </li>
  <li>TIMSK1 - 14.10.17
    <ul>
      </li>Enable OCIE1A, disable all others</li>
    </ul>
  </li>
  <li>TIFR1 - 14.10.19
    <ul>
      <li>Write 0xFF once to clear all pending IRQs</li>
      <li>Just to be safe</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>The setup code</h3>
<pre><code data-trim>#include &lt;avr/io.h&gt;

{
	TCCR1A = 0;
	TCCR1C = 0;
	TCNT1  = 0;
	OCR1A  = 7812;
	TIMSK1 = 1 << OCIE1A;
	TIFR1  = 0xFF;
	// Set TCCR1B last because setting CS starts the T/C
	TCCR1B = (1 << WGM12) | (5 << CS10);
}</code></pre>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
  <li>Task: Transform the busy loop from module 1 into a timer-driven blinking LED.
    <ul>
      <li><pre class="inline">cp module1.c module2.c</pre></li>
    </ul>
  </li>
  <li>Info:
    <ul>
      <li>Use T/C 1 in CTC mode</li>
      <li>Remember to enable interrupts after setup</li>
    </ul>
  </li>
  <li>Question:
    <ul>
      <li>Which interrupt to hook?</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Tips & Tricks</h3>
<ul>
  <li>Toggle a port pin value using XOR:
    <ul>
      <li><pre class="inline"><code data-trim>PORTE ^= 1 << PE6;</code></pre>
    </ul>
  </li>
  <li>Save power by using Sleep Mode in main loop
    <ul>
      <li>Chapter 7 of datasheet<br/>
          <a href="http://www.nongnu.org/avr-libc/user-manual/group__avr__sleep.html">avr-libc sleep mode documentation</a>
      </li>
    </ul>
  </li>
</ul>
</section>


<!--
#######################################################
#######################################################

                 META INFORMATION

#######################################################
#######################################################
-->

<section id="meta"><h3>Meta Information</h3>
  <ul>
    <li>Slides: <a href="https://github.com/shackspace/uc-basics">github.com/shackspace/uc-basics</a></li>
    <li>Datasheets
      <ul>
        <li>Microcontroller (ATmega23U4): <a href="http://bit.ly/1jjFFMb">bit.ly/1jjFFMb</a></li>
        <li>LED</li>
        <li>Shift Register (74595)</li>
      </ul>
    </li>
    <li>Contact Info
      <ul>
        <li>Joachim Fenkes<br/>
        @dop3j0e, github.com/dop3j0e, uc-basics@dojoe.net</li>
        <li>Gregor Jehle<br/>
        @hdznrrd, github.com/hdznrrd, uc-basics@follvalsch.de</li>
      </ul>
    </li>
  </ul>
</section>

<section><h3>Source Attribution</h3>
<div class="attribution">
<ul>
  <li>Samsung Crystal Blue washing machine, CC-BY-NC-SA Samsung Tomorrow, 2015-05-14 15:31, https://www.flickr.com/photos/samsungtomorrow/14180614352/</li>
  <li>Rancilio coffee machine, CC-BY-NC Faye Yu, 2014-05-14 15:42, https://www.flickr.com/photos/fayeyu/7776398/</li>
  <li>Samsung Stainless Steel microwave oven, CC-BY-NC-SA Samsung Tomorrow, 2015-05-14 15:47, https://www.flickr.com/photos/samsungtomorrow/7792317532/</li>
  <li>Atmel ATmega32U4 Block Diagram, &copy; 2014 Atmel Corporation, 2015-05-28 15:00, Atmel-7766G-AVR-ATmega16U4-32U4-Datasheet_02/2014</li>
</ul>
</div>
</section>
</div> <!-- slides -->
</div> <!-- reveal -->

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>
<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: false,
    progress: true,
    history: true,
    center: true,

    theme: 'night',
    transition: 'none',

    // Optional libraries used to extend on reveal.js
    dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ]
  });
</script>
</body>
</html>
