<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Introduction to Microcontroller Programming</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="js/jquery-2.1.1.min.js" type="text/javascript"></script>
  <script src="js/larson.js" type="text/javascript"></script>
  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/default.css" id="theme">
  <link rel="stylesheet" href="lib/css/railscasts.css">
  <link rel="stylesheet" href="lib/font-awesome-4.1.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="css/itmp.css">
  <link rel="stylesheet" href="css/larson.css" />
  <!--[if lt IE 9]><script src="lib/js/html5shiv.js"></script><![endif]-->
</head>
<body>
<div class="reveal">
<div id="staticnav">
  <i class="fa fa-bars fa-2x"></i>
  <br />
  <ul>
    <li><a href="#/introduction">Introduction</a></li>
    <li><a href="#/hello-world">Module 1: Hello, World!</a></li>
    <li><a href="#/irq-and-timers">Module 2: Interrupts &amp; Timers</a></li>
    <li><a href="#/leds-and-io">Module 3: LEDs &amp; I/O</a></li>
    <li><a href="#/button-control">Module 4: Button Control</a></li>
    <li><a href="#/extending-io">Module 5: Extending your I/O</a></li>
    <li><a href="#/wrapping-up">Wrapping Up</a></li>
    <li><a href="#/meta">Meta Information</a></li>
  </ul>
</div>

<!--
#######################################################
#######################################################

                        PRELUDE

#######################################################
#######################################################
-->


<div class="slides">
<section><h4>Introduction to</h4>
  <h3>Microcontroller Programming</h3>
  <h4>using an Atmel ATmega32U4</h4>
  <div>
    <p>Joachim Fenkes (@dop3j0e)</p>
    <p>Gregor Jehle (@hdznrrd)</p>
  </div>
  <img src="lib/external/ccbyncsa.png">
  <div style="margin-top: 3em">View online: <a href="https://rawgit.com/shackspace/uc-basics/master/index.html">bit.ly/uc-basics</a></div>
<aside class="notes">
	Note regarding parts: Don't hand out parts right away; people will natually look at them, play with them, and generally pay less attention. Rather hand out parts just before you build anything, and only the parts needed for the module, so fast people can't work too far in advance.
</aside>
</section>

<section><h3>Today's Goals</h3>
<ul>
  <li>Understand
    <ul class="fragment">
      <li>Microcontroller programming basics</li>
      <li>I/O and Hardware assist units</li>
      <li>Basic external peripherals</li>
      <li>Reading Datasheets</li>
    </ul>
  </li>
  <li>Implement
    <ul class="fragment">
      <li>Hello World</li>
      <li>LED Larson Scanner</li>
      <li>Button Control</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>Who we are</h3>
<ul>
  <li>Joachim "Jocki" Fenkes
    <ul>
      <li>created the board we're using today</li>
    </ul>
  </li>

  <li>Gregor "hadez" Jehle
    <ul>
      <li>used to program MCUs for a living</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Who are you?</h3>
<ul>
  <li>Please introduce yourselves with
	  <ul>
      <li>Your name</li>
	    <li><em>One</em> sentence about your prior knowledge with microcontrollers</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>Dedicated to</h3>
Jan-Bernd Themann<br/>
R.I.P., my friend
</section>

<!--
#######################################################
#######################################################

                    INTRODUCTION

#######################################################
#######################################################
-->

<section id="introduction"><h3>What is a Microcontroller?</h3>

"A microcontroller [...] is a <strong>small computer on a single integrated circuit</strong> containing a processor core, memory, and programmable input/output peripherals. Program memory [...] is also often included on chip, as well as a typically small amount of RAM. Microcontrollers are <strong>designed for embedded applications</strong> [...]"<br/>(Source: <a href="https://en.wikipedia.org/w/index.php?title=Microcontroller&oldid=607593541">Wikipedia, bit.ly/1tW56eP</a>)
</section>


<section><h3>Applications</h3>
<div class="example_photo photowrapper"><img src="lib/external/ranciliocoffeemachine.png"><span class="unimportant">CC-BY-NC<br/>Gregor Jehle, Faye Yu</span></div>
<div class="example_photo photowrapper"><img src="lib/external/samsungcrystalblue.png"><span class="unimportant">CC-BY-NC-SA<br/>Gregor Jehle, Samsung Tomorrow</span></div>
<div class="example_photo photowrapper"><img src="lib/external/samsungmicrowave.png"><span class="unimportant">CC-BY-NC-SA<br/>Gregor Jehle, Samsung Tomorrow</span></div>
</section>


<section><h3>Typical block diagram</h3>
<img src="lib/uc_components.svg">
<ul><li><table>
<tr><td>R</td><td>-</td><td>RAM</td></tr>
<tr><td>F</td><td>-</td><td>Program Flash</td></tr>
<tr><td>P</td><td>-</td><td>Craploads of Peripherals</td></tr>
</table></li><ul>
</section>


<section><h3>Limitations</h3>
<ul>
  <li class="fragment" data-fragment-index="1">A uC ain't a PC!</li>
  <li class="fragment" data-fragment-index="1">Optimized for low power and size</li>
  <li class="fragment" data-fragment-index="1">Slow compared to a PC or a smartphone</li>
  <li class="fragment" data-fragment-index="2">Little RAM</li>
  <li class="fragment" data-fragment-index="2">No floating point unit<br>
                                               &rArr; using <code>float</code> or <code>double</code> will be very very very very slow!</li>
  <li class="fragment" data-fragment-index="2">Sometimes not even HW multiplication</li>
</ul>
</section>


<section><h3>Our learning modules today</h3>
<ol>
  <li class="fragment">Hello, World!</li>
  <li class="fragment">Interrupts & Timers</li>
  <li class="fragment">LEDs & I/O</li>
  <li class="fragment">Button Control</li>
  <li class="fragment">Extending your I/O</li>
</ol>
</section>


<section><h3>The ATmega32U4 microcontroller</h3>
<ul>
	<li>8-bit AVR CPU</li>
	<li>Up to 16 MHz on 5V, up to 8 MHz on 3.3V</li>
	<li>32 KiB of program Flash<br>
		<small>4 KiB used for bootloader, so 28 KiB available for programs</small></li>
	<li>2.5 KiB of SRAM</li>
	<li>26 external I/O pins</li>
	<li>Integrated USB controller</li>
</ul>
<aside class="notes">
	We won't be talking about the USB controller today because that's pretty advanced stuff. But you'll be using it whenever you program new firmware into the device.
</aside>
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img src="lib/uc_components.svg">
</section>

<section><h3>The ATmega32U4 microcontroller</h3>
<img class="atmel_components" src="lib/atmel_components.svg">
<aside class="notes">
	Mention that box colors correspond to previous slide.
</aside>
</section>


<section><h3>The TinyMega Board</h3>
<div id="board_overview_description">
<ol>
  <li>The MCU itself</li>
  <li>USB jack</li>
  <li>Lots of labeled I/O pins</li>
  <li>Two LEDs (Green: Power, Blue: User)</li>
  <li>Two buttons (Reset, Bootloader/User)</li>
</ol>
</div>
<div id="board_overview_photos">
<img src="lib/components/tinymega-bottom.svg">
<img src="lib/components/tinymega-top.svg"><br/>
</div>
</section>


<section><h3>The ATmega32U4 datasheet</h3>
<div class="table">
  <div class="tr">
    <div class="td">
    <ul>
      <li class="fragment" data-fragment-index="1">Most important piece of documentation<br/>
      <span class="fragment" data-fragment-index="2"><strong>433 pages o.O</strong></span>
      </li>
      <li class="fragment" data-fragment-index="4">We will guide you to the relevant sections</li>
      <li class="fragment" data-fragment-index="4">General intro to datasheets will follow later</li>
      <li class="fragment" data-fragment-index="5">Get it here: <a href="http://www.atmel.com/Images/Atmel-7766-8-bit-AVR-ATmega16U4-32U4_Datasheet.pdf">bit.ly/1Ht3JLj</a> (PDF)<br/>
      <small>(Note: Hover any shortened link to see where it leads)</small></li>
    <ul>
    </div>
    <div class="td" id="dontpanic">
      <img class="fragment" data-fragment-index="3" src="lib/dontpanic.svg">
    </div>
  </div>
</div>
</section>


<section><h3>Arduino vs. bare metal coding</h3>
<ul>
	<li>Arduino hides the gory details</li>
	<li class="fragment" data-fragment-index="2">Pro: Easier to learn, quick prototyping</li>
	<li class="fragment" data-fragment-index="3">Con: You don't understand how it's done &rarr; "magic"</li>
	<li class="fragment" data-fragment-index="3">Con: Arduino trades speed & size for simplicity</li>
</ul>
<aside class="notes">
	Speed trade-off example: Mapping of pin numbers to ATmega ports/pins via table, so several instructions / memory access vs. single bit set/clear instruction.
</aside>
</section>


<!--
#######################################################
#######################################################

              MODULE 1: LEDs and I/O

#######################################################
#######################################################
-->


<section id="hello-world"><h3>Module 1</h3>
<h4>Hello, World!</h4>

<p>in which an LED will blink!</p>
<!--<p><div class="component"><img src="lib/tinymega_gon_bon-off.gif"></div></p>-->
<p><div class="component"><img src="lib/components/tinymega_gon_bon.svg"></div></p>
</section>


<section><h3>Stuff you will need</h3>

<p><div class="component">
<img src="lib/components/usbcable.svg">
<img src="lib/components/tinymega_goff_boff.svg">
</div></p>
</section>


<section><h3>Structure of MCU firmware</h3>
<ul>
<li>It's a program like any other!</li>
<li class="fragment"><code>main()</code> function comprised of
  <ul>
    <li>Initialization code</li>
    <li>Main loop</li>
  </ul>
</li>
<li class="fragment">avr-libc takes care of the gory stuff</li>
<li class="fragment"><strong>Caveat:</strong> Don't exit the main-loop</li>
</ul>
<aside class="notes">
	If anyone asks: avr-libc puts an infinite loop after main() exits.
</aside>
</section>


<section><h3>avr-libc</h3>
<ul>
	<li>Startup code, platform support</li>
	<li>Standard C library functions</li>
	<li>Access to uC specialties (<code>avr/*.h</code>)</li>
	<li class="fragment" data-fragment-index="2">Home page: <a href="http://www.nongnu.org/avr-libc/">http://bit.ly/1yI2MN0</a></li>
	<li class="fragment" data-fragment-index="2">Prettier docs: <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/">http://bit.ly/1CduWR7</a></li>
</ul>
</section>


<section><h3>General Purpose I/O</h3>
<div class="table">
    <div class="tr">
        <div class="td">
            <ul>
              <li>Most I/O pins of the ATmega can be controlled directly as digital I/O
            </ul>
        </div>
    </div>
    <div class="tr">
        <div class="td">
            <ul>
              <li class="fragment">Output mode
                  <ul>
                      <li>Write a zero (GND) or one (supply voltage, VDD)</li>
                  </ul>
              </li>
              <li class="fragment">Input mode
                  <ul>
                      <li>Convert pin voltage to one or zero and return</li>
                      <li>Optional pull-up resistor selectable by software</li>
                      <li class="fragment"><strong>Caveat: </strong>Some levels are undefined!</li>
                  </ul>
              </li>
            </ul>
        </div>
        <div class="fragment td" id="inputrange">
            <img src="lib/input-range.svg">
        </div>
    </div>
</div>
</section>

<section><h3>General Purpose I/O</h3>
<div>
    <ul>
      <li>Pins are grouped into "ports"
        <ul>
          <li class="fragment">ATmega32U4 has ports B, C, D, E, F</li>
          <li class="fragment">Pins inside a port are numbered 0..7<br/>eg. B1, B2, C7</li>
        </ul>
      </li>
      <li class="fragment"><strong>Caveat:</strong> Not all ports have all pins populated!</li>
    </ul>
</div>
</section>

<section><h3>Port control though registers</h3>
<ul>
  <li>All hardware units in AVR MCUs are controlled through memory-mapped registers
    <ul>
      <li>Like special RAM variables</li>
    </ul>
  </li>
  <li class="fragment" data-fragment-index="1">Each port has three registers
	<ul><li>
	<table>
	<tr>
        <td>PORTx</td>
        <td class="fragment" data-fragment-index="2">&rArr;</td>
        <td class="fragment" data-fragment-index="2">Write output values or enable/disable pull-up</td>
    </tr>
	<tr>
        <td>PINx</td>
        <td class="fragment" data-fragment-index="3">&rArr;</td>
        <td class="fragment" data-fragment-index="3">Read input values <small>(read "Port INput", not "Pin"!)</small></td>
    </tr>
	<tr>
        <td>DDRx</td>
        <td class="fragment" data-fragment-index="4">&rArr;</td>
        <td class="fragment" data-fragment-index="4">Data Direction Register<br/>selects in (0) / out (1) direction per pin</td>
    </tr>
	</table>
	</li></ul>
  </li>
</ul>
</section>


<section><h3>Port control: Example</h3>
<pre><code data-trim class="cpp">#include &lt;avr/io.h&gt;

{
    // After reset, all pins default to input, no pull-up
    PORTB = (1 << PB3);       // Enable pull-up on B3
    DDRB = (1 << PB2);        // Set B2 to output, all others to input
    if (!(PINB & (1 << PB3)))   // If something pulls B3 down...
        PORTB |= (1 << PB2);    // Set B2 to high, keep rest as is
}</code></pre>
<div class="fragment">Register field names in avr-libc are generally <em>shift distances</em>, not values. This is necessary for multi-bit fields.</div>
<aside class="notes">
	If anyone asks about what a pull-up is -- we'll cover that later today.
</aside>
</section>


<section><h3>Simple delay</h3>
<pre><code data-trim>#define F_CPU 16000000UL  // CPU clock is 16 MHz
#include &lt;util/delay.h&gt;

{
    _delay_ms(1000);  // waaaait a sec...
    _delay_us(10);    // and a bit more
}</code></pre>
<aside class="notes">
	These are busy delay loops that work because they know how long specific instructions take based on F_CPU.
</aside>
</section>

<section><h3>Toolchain installation</h3>
<ul>
  <li>Linux
    <ul>
      <li><pre>apt-get install avr-gcc
apt-get install dfu-programmer</pre></li>
      <li>Some distros (e.g. Red Hat) may require explicit <code>avr-libc</code> install</li>
	  <li>If in doubt, search for packages with <code>avr</code> or <code>dfu</code> in their name</li>
    </ul>
  </li>
  <li>Mac OS X
	<ul>
		<li>You'll need the Homebrew package manager: <a href="http://brew.sh/">http://brew.sh/</a></li>
		<li><pre>brew tap larsimmisch/avr
brew install avr-gcc
brew install dfu-programmer</pre></li>
	</ul>
  <li>Windows
    <ul>
      <li>AVR 8-bit Toolchain: <a href="http://www.atmel.com/tools/atmelavrtoolchainforwindows.aspx">bit.ly/1gHcJTy</a></li>
      <li>FLIP programmer: <a href="http://www.atmel.com/tools/FLIP.aspx">bit.ly/1hEOZuC</a></li>
      <li>USB driver, if necessary: <a href="http://shackspace.de/wiki/lib/exe/fetch.php?media=project:tinymega:atm32u4dfu.zip">bit.ly/SXghXb</a> (ZIP)</li>
    </ul>
  </li>
</ul>
<aside class="notes">
	We are not going to spend time setting up a full IDE. There are tools available for every platform, e.g. Eclipse, but any text editor with syntax highlighting will do today.
</aside>
</section>


<section><h3>Template code</h3>
Create a file <code>module1.c</code>:
<pre><code data-trim>#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;

int main(void)
{
    // Setup code goes here
    while (1) {
        // Main loop goes here
    }
}</code></pre>
</section>


<section><h3>Build</h3>
<ol>
  <li>Compile the source<br/>
      <pre class="inline fragment">avr-gcc -mmcu=atmega32u4 -DF_CPU=16000000UL \
        -Os -o module1.elf module1.c</pre>
  </li>
  <li>Generate an Intel HEX file for flashing<br/>
      <pre class="inline fragment">avr-objcopy -O ihex module1.elf module1.hex</pre>
  </li>
  <li>Display the firmware size<br/>
      <pre class="inline fragment">avr-size module1.elf</pre><br/><br/>
      <span class="fragment"><code>text</code> + <code>data</code> &rArr; Flash usage<br/>
	  <code>data</code> + <code>bss</code> &rArr; RAM usage</span>
  </li>
</ol>
<aside class="notes">
	text is the program code. bss is uninitialized data. data is initialized data that is copied from Flash to SRAM before main() is called. There is a way to prevent static data from being copied to RAM -- google for PROGMEM.
</aside>
</section>


<section><h3>Program (Linux)</h3>
<p>
<ol>
  <li>Erase the whole device -- bootloader always needs this<br/>
      <pre class="inline fragment">sudo dfu-programmer atmega32u4 erase</pre>
  </li>
  <li>Program the HEX file we just generated<br/>
      <pre class="inline fragment">sudo dfu-programmer atmega32u4 flash module1.hex</pre>
  </li>
  <li>Have the bootloader jump into the firmware<br/>
      <pre class="inline fragment">sudo dfu-programmer atmega32u4 start</pre>
  </li>
</ol>
<br/><br/>
<span class="fragment">Rumor has it you can save on <pre class="inline">sudo</pre> by adding your user to the <pre class="inline">uucp</pre> group.</span>
</p>
<aside class="notes">
	The default bootloader works in "secure" mode where the only allowed first operation after power-up is erase.
</aside>
</section>


<section><h3>Program (Windows)</h3>
<img src="lib/screenshots/flip.png">
<p>Make sure "Reset" is turned off for your first programs</p>
<aside class="notes">
	No need to mention this, but if anyone asks: "Reset" would reset the device using the watchdog. If the user program doesn't disable the watchdog, the uC will repeatedly reset. Unchecking "reset" will make the bootloader jump to the user program, so the uC state may not be exactly as after a reset.
</aside>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
  <li>Task: Make the user LED on the TinyMega blink with 1 Hz
    <ul>
      <li>(the MCU equivalent of "Hello, World!")</li>
    </ul>
  </li>
  <li class="fragment">Info:
    <ul>
      <li>The LED is connected to pin E6</li>
      <li>Set the pin to 1 to turn on the LED</li>
      <li>Remember to set the pin to output first</li>
      <li>Use a simple delay loop, nothing fancy</li>
      <li>We left a trap for you to discover, so call us if you run into problems ;)</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Base Clock Prescaler</h3>
<ul>
  <li>The ATmega32U4 has an internal clock divider to divide down the external clock.</li>
  <li class="fragment">Example uses:
    <ul>
      <li>Power saving by dynamic frequency switching</li>
      <li>Adapt to lower voltages (only 8 MHz at 3.3V)</li>
    </ul>
  </li>
  <li class="fragment">Trap: Defaults to "divide by 8" in factory settings!</li>
  <li class="fragment">Solution:
  <pre><code data-trim class="cpp">#include &lt;avr/power.h&gt;
clock_prescale_set(clock_div_1);</code></pre>
  </li>
</ul>
<br/><br/>
<aside class="notes">
	Ask whether anyone accidentally made their TinyMega 3.3V. They should use clock_div_2.
</aside>
</section>


<section><h3>Bonus task!</h3>
<p>Make the LED morse SOS, or even arbitrary text.</p>
</section>



<!--
#######################################################
#######################################################

              MODULE 2: Interrupts & Timers

#######################################################
#######################################################
-->


<section id="irq-and-timers"><h3>Module 2</h3>
<h4>Interrupts & Timers</h4>

<p>in which we will waste less CPU cycles!</p>
<p><div class="component"><img src="lib/components/tinymega_gon_bon.svg"></div></p>
</section>


<section><h3>Stuff you will need</h3>
<p><div class="component">
<img src="lib/components/usbcable.svg">
<img src="lib/components/tinymega_goff_boff.svg">
</div></p>
</section>


<section><h3>Problems with the previous solution</h3>
<ul>
  <li>Hogs CPU cycles ("busy waiting" or "polling")</li>
  <li>Burns power: CPU constantly busy</li>
  <li>Adding work will make accurate timing difficult/impossible</li>
</ul>
</section>


<section><h3>Solution: Hardware Timers!</h3>
<ul>
  <li>ATmega32U4 has four Timer/Counter (T/C) modules</li>
  <li>HW counter, counting up at (divided) clock frequency</li>
  <li class="fragment">"Compare registers" to trigger actions at certain values</li>
  <li class="fragment">Can also directly control I/O pins, capture event timestamps, ...</li>
</ul>
</section>


<section><h3>Interrupts (IRQs)</h3>
<ul>
  <li>Asynchronous interruption of program flow</li>
  <li>Can happen at any time, triggered by hardware</li>
  <li class="fragment">Many IRQ sources with own handlers
    <ul>
      <li>Timer overflow, Timer compare, Pin toggle, ...</li>
    </ul>
  </li>
  <li class="fragment">Can be enabled / disabled globally
    <ul><li><table>
      <tr><td><code>sei()</code></td><td>-</td><td>SEt Interrupts</td></tr>
	  <tr><td><code>cli()</code></td><td>-</td><td>CLear Interrupts</td></tr>
    </table></li></ul>
  </li>
</ul>
</section>


<section><h3>Interrupt Handlers</h3>
<ul>
  <li>Special function, "called" through interrupt
    <ul>
      <li>Also called "Interrupt Service Routine" (ISR)</li>
      <li>Return from handler continues program</li>
    </ul>
  </li>
</ul>

<br/><br/>
<pre><code data-trim class="cpp">#include &lt;avr/interrupt.h&gt

ISR(TIMER0_COMPA_vect)
{
    // Code goes here
}</code></pre>

<div>See <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/group__avr__interrupts.html">http://bit.ly/15b5KgO</a> for possible interrupt names</div>
</section>


<section><h3>ISR best practices</h3>
<ul>
  <li>You're just interrupting someone else
    <ul>
      <li>Keep it short!</li>
    </ul>
  </li>
  <li class="fragment">Communication with main loop: shared global variables
    <ul>
      <li>Declare them <code>volatile</code>!<br/>
          Tells compiler they may change without notice
      </li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Setting up a Timer/Counter</h3>
<ul>
  <li>Let's look at the datasheet, chapter 14</li>
  <li class="fragment">o.O So many options!<br/>
    Let's pick a few that make sense for us</li>
</ul>
</section>


<section><h3>Choosing a mode</h3>
<ul>
  <li>We want to wait for a given time, generate an IRQ, repeat</li>
  <li class="fragment">CTC mode (14.8.2) sounds like the one for us:
    <ul>
	  <li>"Clear Timer on Compare match"</li>
      <li>Count to N, interrupt, start back at zero.</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Choosing a prescaler</h3>
<ul>
  <li>T/C1 can count up to 65535</li>
  <li>We want to wait for half a second</li>
  <li class="fragment">Choose slowest prescaler value of CLK/1024
    <ul>
	  <li>How many ticks per second?</li>
      <li class="fragment">15625 ticks per second</li>
    </ul>
  </li>
</ul>
</section>


<section><h3>Building the T/C control registers</h3>
<ul>
  <li>TCCR1A - 14.10.1 <small>(Timer/Counter Control Register A, T/C 1)</small>
    <ul class="fragment">
      <li>We can ignore the Compare Output Modes</li>
      <li>Choose WGM 4: CTC with TOP = OCR1A</li>
    </ul>
  </li>
  <li>TCCR1B - 14.10.3 <small>(Timer/Counter Control Register B, T/C 1)</small>
    <ul class="fragment">
      <li>We can ignore Input Capture</li>
      <li>Clock Select = 0b101 (CLK / 1024)</li>
    </ul>
  </li>
  <li>TCCR1C - 14.10.5 <small>(you get the idea)</small>
    <ul class="fragment">
      <li>Can be ignored</li>
    </ul>
  </li>  
</ul>
</section>


<section><h3>Building the T/C control registers</h3>
<ul>
  <li>OCR1A - 14.10.9 <small>(Output Compare Register A, T/C 1)</small>
    <ul class="fragment">
      <li>Determines IRQ frequency</li>
    </ul>
  </li>
  <li>TIMSK1 - 14.10.17 <small>(Timer Interrupt Mask, T/C 1)</small>
    <ul class="fragment">
      </li>Enable OCIE1A, disable all others<br/><small>(Output Compare A Interrupt Enable, T/C 1)</small></li>
    </ul>
  </li>
  <li>TIFR1 - 14.10.19 <small>(Timer Interrupt Flag Register, T/C 1)</small>
    <ul class="fragment">
      <li>Write 0xFF once to clear all pending IRQs</li>
      <li>Just to be safe</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>The setup code</h3>
<pre><code data-trim class="cpp">#include &lt;avr/io.h&gt;

{
    TCCR1A = 0;            // Control Reg A
    TCCR1C = 0;            // Control Reg C
    TCNT1  = 0;            // Timer/Counter 1 -- the counter itself
    OCR1A  = 7812;         // Output Compare Reg A
    TIMSK1 = 1 << OCIE1A;  // Int Mask = Output Compare A Int Enable
    TIFR1  = 0xFF;         // Interrupt Flag Reg
    // Set Control Reg B last because setting Clock Select (CS) starts the T/C
    TCCR1B = (1 << WGM12) | (5 << CS10);
}</code></pre>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
  <li>Task: Transform the busy loop from module 1 into a timer-driven blinking LED.
    <ul>
      <li><pre><code class="bash">cp module1.c module2.c</code></pre></li>
    </ul>
  </li>
  <li class="fragment">Info:
    <ul>
      <li>Use T/C 1 in CTC mode</li>
      <li>Remember to enable interrupts after setup</li>
    </ul>
  </li>
  <li class="fragment">Question:
    <ul>
      <li>Which interrupt to hook?</li>
    </ul>
  </li>
</ul>
<aside class="notes">
	Answer: TIMER1_COMPA_vect, NOT TIMER1_OVF_vect -- overflow only occurs at 0xFFFF, which we never reach!
</aside>
</section>


<section><h3>Bonus tasks!</h3>
<ol>
  <li>Save power by using Sleep Mode in main loop
    <ul>
      <li>Chapter 7 of datasheet<br/>
        avr-libc sleep mode documentation: <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/group__avr__sleep.html">http://bit.ly/1yMSooS</a>
      </li>
    </ul>
  </li>
  <li>Again, get the LED to morse text</li>
</ol>
</section>


<section><h3>Tips & Tricks</h3>
<ul>
  <li>Toggle a port pin value by writing PINx:
	<ul>
		<li><pre class="inline"><code data-trim class="cpp">PINE = 1 << PE6;</code></pre></li>
		<li>Little known (but documented) AVR feature</li>
	</ul>
  </li>
</ul>
</section>



<!--
#######################################################
#######################################################

                 MODULE 3: LEDs and I/O

#######################################################
#######################################################
-->
<section id="leds-and-io"><h3>Module 3</h3>
<h4>LEDs & I/O</h4>
<p>in which we will revive K.I.T.T.!</p>
<div class="larson anim1"></div>
</section>


<section><h3>Stuff you will need</h3>
<p><div class="component">
<div><img src="lib/components/usbcable.svg"></div>
<div><img src="lib/components/tinymega_goff_boff.svg"></div>
<div><img src="lib/components/breadboard.svg"></div><br/>
<div><img src="lib/components/jumperwire.svg"><br/>several</div>
<div><img src="lib/components/led_red.svg"><br/>8x</div>
<div><img src="lib/components/resistor_180_5.svg"><br/>8x</div>
</div></p>
</section>


<section><h3>LED basics</h3>
<ul>
	<li>Cathode = Minus = short leg = Base plate inside LED<br>
		<small>(German: <strong>K</strong>athode = <strong>k</strong>urzes Bein)</small></li>
	<li>An LED's brightness depends on current</li>
	<li>Typical I<sub>F</sub>: 10..20 mA</li>
	<li>Add "dropper resistor" in series to get the right current</li>
	<li>Let's check the datasheet for the expected V<sub>F</sub>: <a href="http://www.kingbrightusa.com/images/catalog/SPEC/WP113SRDT.pdf">bit.ly/1IbHPdP</a> (PDF)</li>
</ul>
<aside class="notes">
	Draw typical LED schematic with VDD, resistor, LED, GND.
</aside>
</section>


<section><h3>Datasheets</h3>
<ul>
	<li>Typical sections:
		<ol>
			<li>Summary, core features and values</li>
			<li>Basic operation</li>
			<li>Absolute Maximum Ratings</li>
			<li>Device characteristics
				<ul>
					<li>Tables with min/typ/max values</li>
					<li>Graphs</li>
				</ul>
			</li>
			<li>Detailed usage information</li>
			<li>Example application circuits</li>
			<li>Test circuits used</li>
			<li>Package information, solder patterns</li>
			<li>Order information, revisions, disclaimers</li>
		</ol>
	</li>
	
</ul>
</section>


<section><h3>Our LED</h3>
<ul>
	<li>I<sub>F</sub> = 20 mA</li>
	<li>V<sub>F</sub> = 1.85 V</li>
	<li>&rArr; R = (V<sub>DD</sub> - V<sub>F</sub>) / I<sub>F</sub> &asymp; 160 &Omega;</li>
	<li>Pick next higher standard value: 180 &Omega;</li>
</ul>
<aside class="notes">
	Explain LED formula using the schematic you drew.
</aside>
</section>


<section><h3>Recommended coding</h3>
<ul>
	<li>Build upon your code from last module
		<ul>
			<li>Change OCR1A to go faster</li>
		</ul>
	</li>
	<li>Connect all LEDs to pins of the same port
		<ul>
			<li>One assignment to set them all</li>
		</ul>
	</li>
</ul>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
	<li>Task: Implement a Larson Scanner
		<ul>
			<li><pre><code class="bash">cp module2.c module3.c</code></pre></li>
		</ul>
	</li>
	<li>Info:
		<ul>
			<li>Remember correct port setup</li>
		</ul>
	</li>
</ul>
</section>


<section><h3>Bonus task!</h3>
<ul>
	<li>Invent other, more complex patterns</li>
	<li>(from inside to outside, binary counter, etc...)</li>
</ul>
</section>



<!--
#######################################################
#######################################################

                 MODULE 4: Button Control

#######################################################
#######################################################
-->

<section id="button-control"><h3>Module 4</h3>
  <h4>Button Control</h4>
  <p>in which we will succumb to force!</p>
  <p><img src="lib/components/pushbutton.svg"></p>
</section>



<section><h3>Stuff you will need</h3>
<p><div class="component">
<div><img src="lib/components/usbcable.svg"></div>
<div><img src="lib/components/tinymega_goff_boff.svg"></div>
<div><img src="lib/components/breadboard.svg"></div>
<div><img src="lib/components/pushbutton.svg"></div><br/>
<div><img src="lib/components/jumperwire.svg"><br/>several</div>
<div><img src="lib/components/led_red.svg"><br/>8x</div>
<div><img src="lib/components/resistor_180_5.svg"><br/>8x</div>
</div></p>
</section>



<section><h3>Add a button!</h3>
<ul>
  <li>Button will usually connect A to B when pushed
    <ul>
      <li>"Single Pole, Single Throw" - SPST</li>
	  <li><table>
		<tr><td>Pole</td><td>&rArr;</td><td>number of "channels"</td></tr>
		<tr><td>Throw</td><td>&rArr;</td><td>number of positions per channel<br><small>(think "# ways to throw a switch")</small></td></tr>
	  </table></li>
    </ul>
  </li>
  <li>Idea: Push to connect input pin to VDD
    <ul>
      <li>But what happens while not pushed?</li>
    </ul>
  </li>
</ul>
</section>

<section><h3>High-Z / floating state</h3>
<ul>
        <li>Pins that are not connected anywhere
          <ul>
            <li>Called "floating"</li>
            <li>Or High-Z for "high resistance to anywhere"</li>
          </ul>
        </li>
        <li>A floating input will read random values!
          <ul><li>Collects charge though static and ambient noise</li></ul>
        </li>
        <li>Solution: Remove the High-Z condition
          <ul><li>by adding a low-Z path.</li></ul>
        </li>
</ul>
<aside class="notes">
	Draw picture of port pin as capacitor and button to GND.
</aside>
</section>



<section><h3>Pull-up / Pull-down resistors</h3>
<ul>
        <li>Provide a path from pin to defined voltage (VDD, GND)
		  <ul>
			<li>Neither a short circuit nor High-Z</li>
            <li>Typical resistor value: around 10k&Omega;</li>
		  </ul>
        </li>
        <li class="fragment">Pulls floating pin up to VDD or down to GND
        <ul>
          <li>Can be easily overcome by a short circuit, e.g. a button</li>
          <li>SC creates negligible current while pushed -- 0.5 mA for 10k&Omega;, 5V</li>
        </ul>
        </li>
        <li class="fragment">Like a water reservoir (think flush toilet)
          <ul>
            <li>Water level is pin voltage</li>
            <li>Pull-Up is water supply with valve</li>
            <li>Button is big flush valve</li>
         </ul>
        </li>
</ul>
<aside class="notes">
	Add pull-up resistor to drawing.
</aside>
</section>


<section><h3>Full circuit</h3>
<ul>
        <li>Either pull-down with button to VDD or pull-up with button to GND
          <ul><li>Which one should we use?</li></ul>
        </li>
        <li class="fragment" data-fragment-index="2">Reminder: ATmega pins have optional internal pull-up!
          <ul><li>So choose pull-up with button to GND</li></ul>
        </li>
        <li class="fragment" data-fragment-index="2">Switch pin to input + pull-up
          <ul><li>If we read a <em>zero</em>, the button is <em>pushed</em></li></ul>
        </li>
</ul>
</section>



<section><h3>Level triggered vs. edge triggered</h3>
<ul>
        <li>We will poll the button in our main loop</li>
        <li>Options:
          <ol class="alpha">
            <li>Do something whenever polling returns "pushed"
            <ul>
              <li>Will do something every iteration</li>
              <li>"Level triggered"</li>
            </ul>
            </li>
            <li>Do something when button changes from "not pushed" to "pushed"
            <ul>
              <li>Will do something once per button push-release cycle</li>
              <li>"Edge triggered"</li>
            </ul>
            </li>
          </ol>
        </li>
</ul>
<aside class="notes">
	Draw button signal in time plot so the "edge" can be seen.
</aside>
</section>



<section><h3>Now go forth and code!</h3>
<ul>
        <li>Task: Advance Larson Scanner manually instead of timer
        <ul><li><pre><code class="bash">cp module3.c module4.c</code></pre></li></ul>
        </li>
        <li>Info:
          <ul>
            <li>Don't throw away the timer code, just turn off timer</li>
            <li>Move main Larson code into own function</li>
            <li>Poll button in main loop, edge trigger Larson code</li>
            <li>Remember to switch pin to input + pull-up</li>
            <li>We have left a trap for you -- if anything's weird, please speak up!</li>
          </ul>
        </li>
</ul>
</section>



<section><h3>Button contact "bouncing"</h3>
<ul>
        <li>Buttons have mechanical contacts that are not perfect
          <ul>
            <li>When pushed, will bounce ever so slightly</li>
            <li>Causes short on-off-on-off-... sequence</li>
            <li>Will settle into permanent "on" after a short time</li>
          </ul>
        </li>
        <li>Trap: If polling code is fast enough, it will see this!
          <ul><li>Will interpret as several very fast pushes</li></ul>
        </li>
        <li>Only a problem with edge triggering</li>
</ul>

<aside class="notes">Show bouncing on oscilloscope if there's enough time.</aside>
</section>



<section><h3>Debouncing techniques</h3>
<ul>
        <li>Analog filter (lowpass)
          <ul><li>Will smooth out button signal, needs hardware</li></ul>
        </li>
        <li>Digital filtering
          <ul>
            <li>Keep history of last N measurements</li>
            <li>Require all measurements to agree</li>
          </ul>
        </li>
        <li>Slower polling (if possible)
          <ul>
            <li>Bouncing will disappear in time between polls</li>
            <li>Easiest solution</li>
          </ul>
        </li>
</ul>
</section>



<section><h3>Now go forth and code!</h3>
<ul>
        <li>Task: Debounce your button</li>
        <li>Info:
          <ul>
            <li>Use the same source file</li>
            <li>Your choice: digital filter or slower polling</li>
          </ul>
        </li>
</ul>
</section>


<section><h3>Bonus task!</h3>
<p>Use EEPROM to store state across power cycling</p>
<p>Read up on EEPROM at <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/group__avr__eeprom.html">bit.ly/1A8vzaw</a></p>
</section>


<section><h3>Further reading</h3>
<p>ATmega has ways of causing interrupts when an input changes</p>
<ul>
        <li>Pin Change Interrupt
        <ul><li>Triggers on any change</li></ul></li>
        <li>External Interrupt
        <ul><li>Trigger on rising edge, falling edge, or low level</li></ul></li>
</ul>
<p>Check out datasheet chapter 11 for details</p>
<aside class="notes">
	Both methods remove the polling aspect, but you can't debounce them by simply polling slowly -- digital filtering is needed.
</aside>
</section>



<!--
#######################################################
#######################################################

                 MODULE 5: Extending I/O

#######################################################
#######################################################
-->


<section id="extending-io"><h3>Module 5</h3>
<h4>Extending your I/O</h4>	
<p>in which three pins will control 16 LEDs!</p>
<div class="larson anim2"></div>
</section>


<section><h3>Stuff you will need</h3>
<p><div class="component">
<div><img src="lib/components/usbcable.svg"></div>
<div><img src="lib/components/tinymega_goff_boff.svg"></div>
<div><img src="lib/components/breadboard.svg"></div><br/>
<div><img src="lib/components/jumperwire.svg"><br/>several</div>
<div><img src="lib/components/led_red.svg"><br/>16x</div>
<div><img src="lib/components/resistor_180_5.svg"><br/>16x</div>
<div><img src="lib/components/74595_dil.svg"><br/>2x</div>
</div></p>
</section>


<section><h3>What is a shift register?</h3>
<ul>
	<li>Converts serial data to parallel data or vice versa</li>
	<li>Data is shifted in/out bit by bit
		<ul>
			<li>A clock signal triggers a single shift</li>
		</ul>
	</li>
	<li>Our device: Serial in, parallel out (SIPO)</li>
	<li>Latched: Outputs kept static while new data shifted in
		<ul>
			<li>Latch signal changes all outputs at once</li>
		</ul>
	</li>
</ul>
</section>


<section><h3>How do I use a SIPO shift reg?</h3>
<pre><code class="no-highlight">for (i = 0 .. number of bits) {
    set data input pin to next bit
        (starting with outermost bit)
    pulse clock pin
}
pulse latch pin</code>
</pre>
</section>


<section><h3>Daisy Chaining</h3>
<ul>
	<li>A shift reg usually also has a serial output pin</li>
	<li>Can be used as input for another shift reg</li>
	<li>Clock and latch pins can be tied together</li>
	<li>Infinite shift register! \o/</li>
</ul>
<aside class="notes">
	Not arbitrarily infinite. Shift propagation delay is not the problem, because all regs start shifting at the same time, so you only get that once. CLK and LATCH fan-out will become a problem after a while, though.
</aside>
</section>



<section><h3>SN74HC595</h3>
<ul>
	<li>Part of the 74xxx series of standard logic (<a href="https://en.wikipedia.org/wiki/74_series">bit.ly/SaEU1L</a>)
		<ul>
			<li>Lots and lots and lots of parts available (<a href="https://en.wikipedia.org/wiki/List_of_7400_series_integrated_circuits">bit.ly/SwsD89</a>)</li>
			<li>From every vendor</li>
		</ul>
	</li>
	<li><span class="green">VV</span>74<span class="yellow">SS</span><span class="red">NNN</span>
		<ul>
			<li><span class="green">VV</span> - Vendor, e.g. SN for Texas Instruments</li>
			<li><span class="yellow">SS</span> - Series, e.g. HC for High-Speed CMOS</li>
			<li><span class="red">NNN</span> - Function, 595 is latched SIPO</li>
		</ul>
	</li>
</ul>
</section>



<section><h3>SN74HC595 datasheet</h3>
<ul>
	<li>Get the datasheet (<a href="http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf">bit.ly/UdZpfR</a>, PDF)</li>
	<li>This is for an NXP part, but equivalent and more readable</li>
	<li>Unusual pin names:
		<ul>
			<li>SHCP = Shift Clock Pulse = Serial clock</li>
			<li>STCP = Storage Clock Pulse = LATCH</li>
		</ul>
	</li>
</ul>
</section>



<section><h3>Circuit Building</h3>
<ul>
	<li>Put the two 74HC595 onto the breadboard
		<ul>
			<li>Connect VDD and GND, tie <span class="overbar">MR</span> to VDD, <span class="overbar">OE</span> to GND</li>
			<li>First DS to TinyMega, second DS to first Q7S</li>
			<li>Both CLK to one TinyMega pin, both LATCH to another</li>
		</ul>
	</li>
	<li>Now place LEDs and resistors</li>
</ul>
<aside class="notes">
	Fresh out of the tube, the chips' pins are at an angle. Carefully bend them into right angle by putting the pins on a flat surface and applying force to the chip itself.
</aside>
</section>


<section><h3>Circuit Cheat Sheet</h3>
<ul>
	<li>Connect VDD and GND, tie <span class="overbar">MR</span> to VDD, <span class="overbar">OE</span> to GND</li>
	<li>First DS to TinyMega, second DS to first Q7S</li>
	<li>Both CLK to one TinyMega pin, both LATCH to another</li>
	<li><img id="doubleshiftlarson" src="lib/doubleshiftlarson.svg"></li>
</ul>
</section>


<section><h3>Now go forth and code!</h3>
<ul>
	<li>Task: Transform the Larson Scanner to use SIPO
		<ul>
			<li><pre><code class="bash">cp module4.c module5.c</code></pre></li>
		</ul>
	</li>
	<li>Info:
		<ul>
			<li>Use a two-byte buffer for the LED states</li>
			<li>Shift that buffer out to the SIPO</li>
			<li>Use a simple loop, don't try to be smart</li>
		</ul>
	</li>
	<li>Question:
		<ul>
			<li>Do you need delays between bits?</li>
			<li class="fragment">t<sub>pd,SHCP..Q7S</sub> = 32 ns; t<sub>W,SHCP</sub> = 6 ns<br/>
				&rarr; need ~40 ns pulse, 1 / 16 MHz = 62,5 ns &rarr; safe
		</ul>
	</li>
</ul>
</section>


<section><h3>Aside: Debugging technique</h3>
<ul>
	<li>Use unused pin as debug signal</li>
	<li>Set / reset on given events</li>
	<li>Watch on oscilloscope to:
		<ul>
			<li>Measure signal timing</li>
			<li>Find out time taken by code</li>
			<li>Trigger on sporadic events</li>
		</ul>
	</li>
</ul>
<aside class="notes">
	Demonstrate on oscilloscope if time permits.
</aside>
</section>


<!--
#######################################################
#######################################################

                 WRAPPING UP

#######################################################
#######################################################
-->

<section id="wrapping-up"><h3>Wrapping Up: What we touched today</h3>
<img class="atmel_components" src="lib/atmel_components_used.svg">
</section>

<!-- not sure if want
<section><h3>What we touched today</h3>
<ul>
	<li>General setup</li>
	<li>GPIO ports</li>
	<li>Timer / Counter</li>
	<li>Interrupts</li>
	<li>External Input</li>
	<li>Shift Registers</li>
	<li>Hardware SPI</li>
</ul>
</section>
-->

<section><h3>Feedback</h3>
<p>This is the first time we're doing this, so we need your input!</p>
<ul>
	<li>Scope:
		<ul><li>Too much information for one day or not?</li></ul>
	</li>
	<li>Granularity:
		<ul><li>Too many details somewhere? Too little? Just fine?</li></ul>
	</li>
	<li>Prerequisites:
		<ul><li>Did we expect too much prior knowledge anywhere?</li></ul>
	</li>
	<li>Speed:
		<ul><li>Did we go too fast / too slow?</li></ul>
	</li>
	<li>Simplicity:
		<ul><li>Were we hard to follow anywhere?</li></ul>
	</li>
</ul>
<p>We also gladly take feedback via mail =)</p>
</section>



<section><h3>That is all.</h3>
<h2>Now go forth and make stuff!</h2>
<p>Thank you for attending.</p>
</section>

<!--
#######################################################
#######################################################

                 META INFORMATION

#######################################################
#######################################################
-->

<section id="meta"><h3>Meta Information</h3>
  <ul>
    <li>Slides: <a href="https://github.com/shackspace/uc-basics">github.com/shackspace/uc-basics</a></li>
    <li>Datasheets
      <ul>
        <li>Microcontroller (ATmega23U4): <a href="http://www.atmel.com/Images/Atmel-7766-8-bit-AVR-ATmega16U4-32U4_Datasheet.pdf">bit.ly/1Ht3JLj</a> (PDF)</li>
        <li>LED: <a href="http://www.kingbrightusa.com/images/catalog/SPEC/WP113SRDT.pdf">bit.ly/1IbHPdP</a> (PDF)</li>
        <li>Shift Register (74595): <a href="http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf">bit.ly/UdZpfR</a> (PDF)</li>
      </ul>
    </li>
    <li>Contact Info
      <ul>
        <li>Joachim Fenkes<br/>
        @dop3j0e, github.com/dop3j0e, uc-basics<small>at</small>dojoe<small>dot</small>net</li>
        <li>Gregor Jehle<br/>
        @hdznrrd, github.com/hdznrrd, uc-basics<small>at</small>follvalsch<small>dot</small>de</li>
      </ul>
    </li>
  </ul>
</section>

<section><h3>Links to relevant avr-libc docs</h3>
<ul>
	<li>Base documentation: <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/">http://bit.ly/1CduWR7</a></li>
	<li>Interrupts: <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/group__avr__interrupts.html">http://bit.ly/15b5KgO</a></li>
	<li>Power & Clocks: <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/group__avr__power.html">http://bit.ly/1BGLSAr</a></li>
	<li>Sleep mode: <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/group__avr__sleep.html">http://bit.ly/1yMSooS</a></li>
	<li>EEPROM access: <a href="http://www.atmel.com/webdoc/AVRLibcReferenceManual/group__avr__eeprom.html">http://bit.ly/1Bf4qFh</a></li>
</ul>
</section>

<section><h3>Source Attribution</h3>
<div class="attribution">
<ul>
  <li>Samsung Crystal Blue washing machine
  <ul>
    <li>CC-BY-NC-SA Gregor Jehle</li>
    <li>Original: CC-BY-NC-SA Samsung Tomorrow, 2014-05-14 15:31, https://www.flickr.com/photos/samsungtomorrow/14180614352/</li>
  </ul>
  </li>
  <li>Rancilio coffee machine
  <ul>
    <li>CC-BY-NC Gregor Jehle</li>
    <li>Original: CC-BY-NC Faye Yu, 2014-05-14 15:42, https://www.flickr.com/photos/fayeyu/7776398/</li>
  </ul>
  </li>
  <li>Samsung Stainless Steel microwave oven
  <ul>
    <li>CC-BY-NC-SA Gregor Jehle</li>
    <li>Original: CC-BY-NC-SA Samsung Tomorrow, 2014-05-14 15:47, https://www.flickr.com/photos/samsungtomorrow/7792317532/</li>
  </ul>
  </li>
  <li>Atmel ATmega32U4 Block Diagram
  <ul>
    <li>Color highlighting: CC-0 Gregor Jehle</li>
    <li>Original: &copy; 2014 Atmel Corporation, 2014-05-28 15:00, Atmel-7766G-AVR-ATmega16U4-32U4-Datasheet_02/2014</li>
  </ul>
  </li>
</ul>
</div>
</section>
</div> <!-- slides -->
</div> <!-- reveal -->

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>
<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: false,
    progress: true,
    history: true,
    center: true,

    theme: 'night',
    transition: 'none',

    // Optional libraries used to extend on reveal.js
    dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ]
  });
</script>
<script type="text/javascript">
$(document).ready(function(){ 
    $('.anim1').larson(8).larson('start');
    $('.anim2').larson(16).larson('start');
    $('.anim3').larson(16).larson('start');
});
</script>
</body>
</html>
