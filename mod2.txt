Module 2

Interrupts & Timers

in which we will waste less CPU cycles!

[gif: blinkender tinymega]



Stuff you will need

[tinymega] [usb-kabel] [notebook]



Problems with the previous solution

Hogs CPU cycles ("busy waiting")
Burns power: CPU constantly busy
Adding work will make accurate timing difficult/impossible



Solution: Hardware Timers!

ATmega32U4 has four Timer/Counter (T/C) modules
HW counter, counting up at (divided) clock frequency
Compare registers to trigger actions at certain values
Can also directly control I/O pins, capture event timestamps, ...



Interrupts (IRQs)

Asynchronous interruption of program flow
Can happen at any time, triggered by hardware
Many IRQ sources with own handlers
  Timer overflow, Timer compare, Pin toggle, ...
Can be enabled / disabled globally
  <code>sei()</code>, <code>cli()</code>

  
  
Interrupt Handlers
  
Special function, "called" through interrupt
  Also called "Interrupt Service Routine" (ISR)
  Return from handler continues program

#include <avr/interrupt.h>

ISR(TIMER0_COMPA_vect)
{
	// Code goes here
}



ISR best practices

You're just interrupting someone else
  Keep it short!

Communication with main loop: shared global variables
  Declare them <code>volatile</code>!
    Tells compiler they may change without notice



Setting up a Timer/Counter

Let's look at the datasheet, chapter 14

o.O So many options!
Let's pick a few that make sense for us



Choosing a mode

We want to wait for a given time, generate an IRQ, repeat
CTC mode (14.8.2) sounds like the one for us:
  Count to N, interrupt, start back at zero.

  
  
Choosing a prescaler

T/C1 can count up to 65536
We want to wait for half a second
Choose slowest prescaler value of CLK/1024
  15625 ticks per second



Building the T/C control registers

TCCR1A - 14.10.1
  We can ignore the Compare Output Modes
  Choose WGM 4: CTC with TOP = OCR1A

TCCR1B - 14.10.3
  We can ignore Input Capture
  Clock Select = 0b101 (CLK / 1024)

TCCR1C - 14.10.5
  Can be ignored
  


Building the T/C control registers

OCR1A - 14.10.9
  Determines IRQ frequency
  
TIMSK1 - 14.10.17
  Enable OCIE1A, disable all others
  
TIFR1 - 14.10.19
  Write 0xFF once to clear all pending IRQs
  Just to be safe


  
The setup code

#include <avr/io.h>

{
	TCCR1A = 0;
	TCCR1C = 0;
	TCNT1  = 0;
	OCR1A  = 7812;
	TIMSK1 = 1 << OCIE1A;
	TIFR1  = 0xFF;
	// Set TCCR1B last because setting CS starts the T/C
	TCCR1B = (1 << WGM12) | (5 << CS10);
}
  
  

Now go forth and code!

Task: Transform the busy loop from module 1 into a timer-driven blinking LED.
      <code>cp module1.c module2.c</code>

Info:
  Use T/C 1 in CTC mode
  Remember to enable interrupts after setup

Questions:
  Which interrupt to hook?



Tips & Tricks

Toggle a port pin value using XOR:
  <code>PORTE ^= 1 << PE6;</code>

Save power by using Sleep Mode in main loop
  Chapter 7 of datasheet
  <a href="http://www.nongnu.org/avr-libc/user-manual/group__avr__sleep.html">avr-libc sleep mode documentation</a>
