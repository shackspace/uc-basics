Module 1

Hello, World!

in which an LED will blink!

[gif: blinkender tinymega]



Stuff you will need

[tinymega] [usb-kabel] [notebook]



Structure of MCU firmware

It's a program like any other!

<code>main()</code> function
  Initialization code
  Main loop
Main loop is never exited



General Purpose I/O

Most I/O pins of the ATmega can be controlled directly as digital I/O
  Input or output mode
    Output mode: Write a zero (GND) or one (supply voltage, VDD)
    Input mode: Convert pin voltage to one or zero and return
      Optional pull-up resistor selectable by software

Pins are grouped into "ports"
  ATmega32U4 has ports B, C, D, E, F
  Pins inside a port are numbered 0..7
    Ex. B1, B2, C7
  Not all ports have all pins populated



Port control though registers

All hardware units in AVR MCUs are controlled through memory-mapped registers
  Like special RAM variables

Each port has three registers
  PORTx -- Write output values or enable/disable pull-up
  PINx  -- Read input values
  DDRx  -- Data Direction Register; selects in (0) / out (1) direction per pin



Port control: Example

#include <avr/io.h>

{
	// After reset, all pins default to input, no pull-up
	PORTB = (1 << PB3);		// Enable pull-up on B3
	DDRB = (1 << PB2);		// Set B2 to output, all others to input
	if (!(PINB & _BV(PB3)))		// If something pulls B3 down...
		PORTB |= _BV(PB2);	// Set B2 to high, keep rest as is
}



Simple delay

#define F_CPU 16000000UL  // CPU clock is 16 MHz
#include <util/delay.h>

{
	_delay_ms(1000);  // waaaait a sec...
	_delay_us(10);    // and a bit more
}



Hands On!

Toolchain installation

Linux
  apt-get install avr-gcc dfu-programmer

Windows
  <a href="http://www.atmel.com/tools/atmelavrtoolchainforwindows.aspx">AVR 8-bit Toolchain</a>
  <a href="http://www.atmel.com/tools/FLIP.aspx">FLIP programmer</a>
  <a href="http://shackspace.de/wiki/lib/exe/fetch.php?media=project:tinymega:atm32u4dfu.zip">USB driver</a> (if necessary)



Template code

Create a file <code>module1.c</code>:

#include <avr/io.h>
#include <util/delay.h>

int main(void)
{
	// Setup code goes here
	while (1) {
		// Main loop goes here
	}
}



Build

Compile the source
	<code>avr-gcc -mmcu=atmega32u4 -DF_CPU=16000000UL -Os -o module1.elf module1.c</code>
	
Generate an Intel HEX file for flashing
	<code>avr-objcopy -O ihex module1.elf module1.hex</code>
	
Display the firmware size
	<code>avr-size module1.elf</code>
	<code>text + data</code> is Flash usage
	<code>data + bss</code> is RAM usage


	
Program (Linux)

# Erase the whole device -- bootloader always needs this
sudo dfu-programmer atmega32u4 erase

# Program the HEX file we just generated
sudo dfu-programmer atmega32u4 flash module1.hex

# Have the bootloader jump into the firmware
sudo dfu-programmer atmega32u4 start

Rumor has it you can save on <code>sudo</code> by adding your user to the <code>uucp</code> group.



Program (Windows)

http://shackspace.de/wiki/lib/exe/fetch.php?media=project:tinymega:flip.png



Now go forth and code!

Task: Make the user LED on the TinyMega blink with 1 Hz
      (the MCU equivalent of "Hello, World!")

Info:
  The LED is connected to pin E6
  Set the pin to 1 to turn on the LED
  Remember to set the pin to output first
  Use a simple delay loop, nothing fancy
  We left a trap for you to discover, so call us if you run into problems ;)

  

Base Clock Prescaler

The ATmega32U4 has an internal clock divider to divide down the external clock.
Example uses:
  Power saving by dynamic frequency switching
  Adapt to lower voltages (only 8 MHz at 3.3V)

Trap: Defaults to "divide by 8" in factory settings!

#include <avr/power.h>

clock_prescale_set(clock_div_1);
